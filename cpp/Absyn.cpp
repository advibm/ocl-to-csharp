//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.h"

/********************   OCLf    ********************/
OCLf::OCLf(ListOCLPackage *p1)
{
  listoclpackage_ = p1;

}

OCLf::OCLf(const OCLf & other)
{
  listoclpackage_ = other.listoclpackage_->clone();

}

OCLf &OCLf::operator=(const OCLf & other)
{
  OCLf tmp(other);
  swap(tmp);
  return *this;
}

void OCLf::swap(OCLf & other)
{
  std::swap(listoclpackage_, other.listoclpackage_);

}

OCLf::~OCLf()
{
  delete(listoclpackage_);

}

void OCLf::accept(Visitor *v)
{
  v->visitOCLf(this);
}

OCLf *OCLf::clone() const
{
  return new OCLf(*this);
}



/********************   Pack    ********************/
Pack::Pack(PackageName *p1, OCLExpressions *p2)
{
  packagename_ = p1;
  oclexpressions_ = p2;

}

Pack::Pack(const Pack & other)
{
  packagename_ = other.packagename_->clone();
  oclexpressions_ = other.oclexpressions_->clone();

}

Pack &Pack::operator=(const Pack & other)
{
  Pack tmp(other);
  swap(tmp);
  return *this;
}

void Pack::swap(Pack & other)
{
  std::swap(packagename_, other.packagename_);
  std::swap(oclexpressions_, other.oclexpressions_);

}

Pack::~Pack()
{
  delete(packagename_);
  delete(oclexpressions_);

}

void Pack::accept(Visitor *v)
{
  v->visitPack(this);
}

Pack *Pack::clone() const
{
  return new Pack(*this);
}



/********************   PackName    ********************/
PackName::PackName(PathName *p1)
{
  pathname_ = p1;

}

PackName::PackName(const PackName & other)
{
  pathname_ = other.pathname_->clone();

}

PackName &PackName::operator=(const PackName & other)
{
  PackName tmp(other);
  swap(tmp);
  return *this;
}

void PackName::swap(PackName & other)
{
  std::swap(pathname_, other.pathname_);

}

PackName::~PackName()
{
  delete(pathname_);

}

void PackName::accept(Visitor *v)
{
  v->visitPackName(this);
}

PackName *PackName::clone() const
{
  return new PackName(*this);
}



/********************   Constraints    ********************/
Constraints::Constraints(ListConstrnt *p1)
{
  listconstrnt_ = p1;

}

Constraints::Constraints(const Constraints & other)
{
  listconstrnt_ = other.listconstrnt_->clone();

}

Constraints &Constraints::operator=(const Constraints & other)
{
  Constraints tmp(other);
  swap(tmp);
  return *this;
}

void Constraints::swap(Constraints & other)
{
  std::swap(listconstrnt_, other.listconstrnt_);

}

Constraints::~Constraints()
{
  delete(listconstrnt_);

}

void Constraints::accept(Visitor *v)
{
  v->visitConstraints(this);
}

Constraints *Constraints::clone() const
{
  return new Constraints(*this);
}



/********************   Constr    ********************/
Constr::Constr(ContextDeclaration *p1, ListConstrBody *p2)
{
  contextdeclaration_ = p1;
  listconstrbody_ = p2;

}

Constr::Constr(const Constr & other)
{
  contextdeclaration_ = other.contextdeclaration_->clone();
  listconstrbody_ = other.listconstrbody_->clone();

}

Constr &Constr::operator=(const Constr & other)
{
  Constr tmp(other);
  swap(tmp);
  return *this;
}

void Constr::swap(Constr & other)
{
  std::swap(contextdeclaration_, other.contextdeclaration_);
  std::swap(listconstrbody_, other.listconstrbody_);

}

Constr::~Constr()
{
  delete(contextdeclaration_);
  delete(listconstrbody_);

}

void Constr::accept(Visitor *v)
{
  v->visitConstr(this);
}

Constr *Constr::clone() const
{
  return new Constr(*this);
}



/********************   CBDefNamed    ********************/
CBDefNamed::CBDefNamed(Ident p1, ListLetExpression *p2)
{
  ident_ = p1;
  listletexpression_ = p2;

}

CBDefNamed::CBDefNamed(const CBDefNamed & other)
{
  ident_ = other.ident_;
  listletexpression_ = other.listletexpression_->clone();

}

CBDefNamed &CBDefNamed::operator=(const CBDefNamed & other)
{
  CBDefNamed tmp(other);
  swap(tmp);
  return *this;
}

void CBDefNamed::swap(CBDefNamed & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listletexpression_, other.listletexpression_);

}

CBDefNamed::~CBDefNamed()
{
  delete(listletexpression_);

}

void CBDefNamed::accept(Visitor *v)
{
  v->visitCBDefNamed(this);
}

CBDefNamed *CBDefNamed::clone() const
{
  return new CBDefNamed(*this);
}



/********************   CBDef    ********************/
CBDef::CBDef(ListLetExpression *p1)
{
  listletexpression_ = p1;

}

CBDef::CBDef(const CBDef & other)
{
  listletexpression_ = other.listletexpression_->clone();

}

CBDef &CBDef::operator=(const CBDef & other)
{
  CBDef tmp(other);
  swap(tmp);
  return *this;
}

void CBDef::swap(CBDef & other)
{
  std::swap(listletexpression_, other.listletexpression_);

}

CBDef::~CBDef()
{
  delete(listletexpression_);

}

void CBDef::accept(Visitor *v)
{
  v->visitCBDef(this);
}

CBDef *CBDef::clone() const
{
  return new CBDef(*this);
}



/********************   CBNamed    ********************/
CBNamed::CBNamed(Stereotype *p1, Ident p2, OCLExpression *p3)
{
  stereotype_ = p1;
  ident_ = p2;
  oclexpression_ = p3;

}

CBNamed::CBNamed(const CBNamed & other)
{
  stereotype_ = other.stereotype_->clone();
  ident_ = other.ident_;
  oclexpression_ = other.oclexpression_->clone();

}

CBNamed &CBNamed::operator=(const CBNamed & other)
{
  CBNamed tmp(other);
  swap(tmp);
  return *this;
}

void CBNamed::swap(CBNamed & other)
{
  std::swap(stereotype_, other.stereotype_);
  std::swap(ident_, other.ident_);
  std::swap(oclexpression_, other.oclexpression_);

}

CBNamed::~CBNamed()
{
  delete(stereotype_);
  delete(oclexpression_);

}

void CBNamed::accept(Visitor *v)
{
  v->visitCBNamed(this);
}

CBNamed *CBNamed::clone() const
{
  return new CBNamed(*this);
}



/********************   CB    ********************/
CB::CB(Stereotype *p1, OCLExpression *p2)
{
  stereotype_ = p1;
  oclexpression_ = p2;

}

CB::CB(const CB & other)
{
  stereotype_ = other.stereotype_->clone();
  oclexpression_ = other.oclexpression_->clone();

}

CB &CB::operator=(const CB & other)
{
  CB tmp(other);
  swap(tmp);
  return *this;
}

void CB::swap(CB & other)
{
  std::swap(stereotype_, other.stereotype_);
  std::swap(oclexpression_, other.oclexpression_);

}

CB::~CB()
{
  delete(stereotype_);
  delete(oclexpression_);

}

void CB::accept(Visitor *v)
{
  v->visitCB(this);
}

CB *CB::clone() const
{
  return new CB(*this);
}



/********************   CDOper    ********************/
CDOper::CDOper(OperationContext *p1)
{
  operationcontext_ = p1;

}

CDOper::CDOper(const CDOper & other)
{
  operationcontext_ = other.operationcontext_->clone();

}

CDOper &CDOper::operator=(const CDOper & other)
{
  CDOper tmp(other);
  swap(tmp);
  return *this;
}

void CDOper::swap(CDOper & other)
{
  std::swap(operationcontext_, other.operationcontext_);

}

CDOper::~CDOper()
{
  delete(operationcontext_);

}

void CDOper::accept(Visitor *v)
{
  v->visitCDOper(this);
}

CDOper *CDOper::clone() const
{
  return new CDOper(*this);
}



/********************   CDClassif    ********************/
CDClassif::CDClassif(ClassifierContext *p1)
{
  classifiercontext_ = p1;

}

CDClassif::CDClassif(const CDClassif & other)
{
  classifiercontext_ = other.classifiercontext_->clone();

}

CDClassif &CDClassif::operator=(const CDClassif & other)
{
  CDClassif tmp(other);
  swap(tmp);
  return *this;
}

void CDClassif::swap(CDClassif & other)
{
  std::swap(classifiercontext_, other.classifiercontext_);

}

CDClassif::~CDClassif()
{
  delete(classifiercontext_);

}

void CDClassif::accept(Visitor *v)
{
  v->visitCDClassif(this);
}

CDClassif *CDClassif::clone() const
{
  return new CDClassif(*this);
}



/********************   CCType    ********************/
CCType::CCType(Ident p1, Ident p2)
{
  ident_1 = p1;
  ident_2 = p2;

}

CCType::CCType(const CCType & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;

}

CCType &CCType::operator=(const CCType & other)
{
  CCType tmp(other);
  swap(tmp);
  return *this;
}

void CCType::swap(CCType & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);

}

CCType::~CCType()
{

}

void CCType::accept(Visitor *v)
{
  v->visitCCType(this);
}

CCType *CCType::clone() const
{
  return new CCType(*this);
}



/********************   CC    ********************/
CC::CC(Ident p1)
{
  ident_ = p1;

}

CC::CC(const CC & other)
{
  ident_ = other.ident_;

}

CC &CC::operator=(const CC & other)
{
  CC tmp(other);
  swap(tmp);
  return *this;
}

void CC::swap(CC & other)
{
  std::swap(ident_, other.ident_);

}

CC::~CC()
{

}

void CC::accept(Visitor *v)
{
  v->visitCC(this);
}

CC *CC::clone() const
{
  return new CC(*this);
}



/********************   OpC    ********************/
OpC::OpC(Ident p1, OperationName *p2, ListFormalParameter *p3)
{
  ident_ = p1;
  operationname_ = p2;
  listformalparameter_ = p3;

}

OpC::OpC(const OpC & other)
{
  ident_ = other.ident_;
  operationname_ = other.operationname_->clone();
  listformalparameter_ = other.listformalparameter_->clone();

}

OpC &OpC::operator=(const OpC & other)
{
  OpC tmp(other);
  swap(tmp);
  return *this;
}

void OpC::swap(OpC & other)
{
  std::swap(ident_, other.ident_);
  std::swap(operationname_, other.operationname_);
  std::swap(listformalparameter_, other.listformalparameter_);

}

OpC::~OpC()
{
  delete(operationname_);
  delete(listformalparameter_);

}

void OpC::accept(Visitor *v)
{
  v->visitOpC(this);
}

OpC *OpC::clone() const
{
  return new OpC(*this);
}



/********************   OpCRT    ********************/
OpCRT::OpCRT(Ident p1, OperationName *p2, ListFormalParameter *p3, ReturnType *p4)
{
  ident_ = p1;
  operationname_ = p2;
  listformalparameter_ = p3;
  returntype_ = p4;

}

OpCRT::OpCRT(const OpCRT & other)
{
  ident_ = other.ident_;
  operationname_ = other.operationname_->clone();
  listformalparameter_ = other.listformalparameter_->clone();
  returntype_ = other.returntype_->clone();

}

OpCRT &OpCRT::operator=(const OpCRT & other)
{
  OpCRT tmp(other);
  swap(tmp);
  return *this;
}

void OpCRT::swap(OpCRT & other)
{
  std::swap(ident_, other.ident_);
  std::swap(operationname_, other.operationname_);
  std::swap(listformalparameter_, other.listformalparameter_);
  std::swap(returntype_, other.returntype_);

}

OpCRT::~OpCRT()
{
  delete(operationname_);
  delete(listformalparameter_);
  delete(returntype_);

}

void OpCRT::accept(Visitor *v)
{
  v->visitOpCRT(this);
}

OpCRT *OpCRT::clone() const
{
  return new OpCRT(*this);
}



/********************   Pre    ********************/
Pre::Pre()
{

}

Pre::Pre(const Pre & other)
{

}

Pre &Pre::operator=(const Pre & other)
{
  Pre tmp(other);
  swap(tmp);
  return *this;
}

void Pre::swap(Pre & other)
{

}

Pre::~Pre()
{

}

void Pre::accept(Visitor *v)
{
  v->visitPre(this);
}

Pre *Pre::clone() const
{
  return new Pre(*this);
}



/********************   Post    ********************/
Post::Post()
{

}

Post::Post(const Post & other)
{

}

Post &Post::operator=(const Post & other)
{
  Post tmp(other);
  swap(tmp);
  return *this;
}

void Post::swap(Post & other)
{

}

Post::~Post()
{

}

void Post::accept(Visitor *v)
{
  v->visitPost(this);
}

Post *Post::clone() const
{
  return new Post(*this);
}



/********************   Inv    ********************/
Inv::Inv()
{

}

Inv::Inv(const Inv & other)
{

}

Inv &Inv::operator=(const Inv & other)
{
  Inv tmp(other);
  swap(tmp);
  return *this;
}

void Inv::swap(Inv & other)
{

}

Inv::~Inv()
{

}

void Inv::accept(Visitor *v)
{
  v->visitInv(this);
}

Inv *Inv::clone() const
{
  return new Inv(*this);
}



/********************   OpName    ********************/
OpName::OpName(Ident p1)
{
  ident_ = p1;

}

OpName::OpName(const OpName & other)
{
  ident_ = other.ident_;

}

OpName &OpName::operator=(const OpName & other)
{
  OpName tmp(other);
  swap(tmp);
  return *this;
}

void OpName::swap(OpName & other)
{
  std::swap(ident_, other.ident_);

}

OpName::~OpName()
{

}

void OpName::accept(Visitor *v)
{
  v->visitOpName(this);
}

OpName *OpName::clone() const
{
  return new OpName(*this);
}



/********************   Eq    ********************/
Eq::Eq()
{

}

Eq::Eq(const Eq & other)
{

}

Eq &Eq::operator=(const Eq & other)
{
  Eq tmp(other);
  swap(tmp);
  return *this;
}

void Eq::swap(Eq & other)
{

}

Eq::~Eq()
{

}

void Eq::accept(Visitor *v)
{
  v->visitEq(this);
}

Eq *Eq::clone() const
{
  return new Eq(*this);
}



/********************   Add    ********************/
Add::Add()
{

}

Add::Add(const Add & other)
{

}

Add &Add::operator=(const Add & other)
{
  Add tmp(other);
  swap(tmp);
  return *this;
}

void Add::swap(Add & other)
{

}

Add::~Add()
{

}

void Add::accept(Visitor *v)
{
  v->visitAdd(this);
}

Add *Add::clone() const
{
  return new Add(*this);
}



/********************   Sub    ********************/
Sub::Sub()
{

}

Sub::Sub(const Sub & other)
{

}

Sub &Sub::operator=(const Sub & other)
{
  Sub tmp(other);
  swap(tmp);
  return *this;
}

void Sub::swap(Sub & other)
{

}

Sub::~Sub()
{

}

void Sub::accept(Visitor *v)
{
  v->visitSub(this);
}

Sub *Sub::clone() const
{
  return new Sub(*this);
}



/********************   LST    ********************/
LST::LST()
{

}

LST::LST(const LST & other)
{

}

LST &LST::operator=(const LST & other)
{
  LST tmp(other);
  swap(tmp);
  return *this;
}

void LST::swap(LST & other)
{

}

LST::~LST()
{

}

void LST::accept(Visitor *v)
{
  v->visitLST(this);
}

LST *LST::clone() const
{
  return new LST(*this);
}



/********************   LSTE    ********************/
LSTE::LSTE()
{

}

LSTE::LSTE(const LSTE & other)
{

}

LSTE &LSTE::operator=(const LSTE & other)
{
  LSTE tmp(other);
  swap(tmp);
  return *this;
}

void LSTE::swap(LSTE & other)
{

}

LSTE::~LSTE()
{

}

void LSTE::accept(Visitor *v)
{
  v->visitLSTE(this);
}

LSTE *LSTE::clone() const
{
  return new LSTE(*this);
}



/********************   GRT    ********************/
GRT::GRT()
{

}

GRT::GRT(const GRT & other)
{

}

GRT &GRT::operator=(const GRT & other)
{
  GRT tmp(other);
  swap(tmp);
  return *this;
}

void GRT::swap(GRT & other)
{

}

GRT::~GRT()
{

}

void GRT::accept(Visitor *v)
{
  v->visitGRT(this);
}

GRT *GRT::clone() const
{
  return new GRT(*this);
}



/********************   GRTE    ********************/
GRTE::GRTE()
{

}

GRTE::GRTE(const GRTE & other)
{

}

GRTE &GRTE::operator=(const GRTE & other)
{
  GRTE tmp(other);
  swap(tmp);
  return *this;
}

void GRTE::swap(GRTE & other)
{

}

GRTE::~GRTE()
{

}

void GRTE::accept(Visitor *v)
{
  v->visitGRTE(this);
}

GRTE *GRTE::clone() const
{
  return new GRTE(*this);
}



/********************   Div    ********************/
Div::Div()
{

}

Div::Div(const Div & other)
{

}

Div &Div::operator=(const Div & other)
{
  Div tmp(other);
  swap(tmp);
  return *this;
}

void Div::swap(Div & other)
{

}

Div::~Div()
{

}

void Div::accept(Visitor *v)
{
  v->visitDiv(this);
}

Div *Div::clone() const
{
  return new Div(*this);
}



/********************   Mult    ********************/
Mult::Mult()
{

}

Mult::Mult(const Mult & other)
{

}

Mult &Mult::operator=(const Mult & other)
{
  Mult tmp(other);
  swap(tmp);
  return *this;
}

void Mult::swap(Mult & other)
{

}

Mult::~Mult()
{

}

void Mult::accept(Visitor *v)
{
  v->visitMult(this);
}

Mult *Mult::clone() const
{
  return new Mult(*this);
}



/********************   NEq    ********************/
NEq::NEq()
{

}

NEq::NEq(const NEq & other)
{

}

NEq &NEq::operator=(const NEq & other)
{
  NEq tmp(other);
  swap(tmp);
  return *this;
}

void NEq::swap(NEq & other)
{

}

NEq::~NEq()
{

}

void NEq::accept(Visitor *v)
{
  v->visitNEq(this);
}

NEq *NEq::clone() const
{
  return new NEq(*this);
}



/********************   Impl    ********************/
Impl::Impl()
{

}

Impl::Impl(const Impl & other)
{

}

Impl &Impl::operator=(const Impl & other)
{
  Impl tmp(other);
  swap(tmp);
  return *this;
}

void Impl::swap(Impl & other)
{

}

Impl::~Impl()
{

}

void Impl::accept(Visitor *v)
{
  v->visitImpl(this);
}

Impl *Impl::clone() const
{
  return new Impl(*this);
}



/********************   Not    ********************/
Not::Not()
{

}

Not::Not(const Not & other)
{

}

Not &Not::operator=(const Not & other)
{
  Not tmp(other);
  swap(tmp);
  return *this;
}

void Not::swap(Not & other)
{

}

Not::~Not()
{

}

void Not::accept(Visitor *v)
{
  v->visitNot(this);
}

Not *Not::clone() const
{
  return new Not(*this);
}



/********************   Or    ********************/
Or::Or()
{

}

Or::Or(const Or & other)
{

}

Or &Or::operator=(const Or & other)
{
  Or tmp(other);
  swap(tmp);
  return *this;
}

void Or::swap(Or & other)
{

}

Or::~Or()
{

}

void Or::accept(Visitor *v)
{
  v->visitOr(this);
}

Or *Or::clone() const
{
  return new Or(*this);
}



/********************   Xor    ********************/
Xor::Xor()
{

}

Xor::Xor(const Xor & other)
{

}

Xor &Xor::operator=(const Xor & other)
{
  Xor tmp(other);
  swap(tmp);
  return *this;
}

void Xor::swap(Xor & other)
{

}

Xor::~Xor()
{

}

void Xor::accept(Visitor *v)
{
  v->visitXor(this);
}

Xor *Xor::clone() const
{
  return new Xor(*this);
}



/********************   And    ********************/
And::And()
{

}

And::And(const And & other)
{

}

And &And::operator=(const And & other)
{
  And tmp(other);
  swap(tmp);
  return *this;
}

void And::swap(And & other)
{

}

And::~And()
{

}

void And::accept(Visitor *v)
{
  v->visitAnd(this);
}

And *And::clone() const
{
  return new And(*this);
}



/********************   FP    ********************/
FP::FP(Ident p1, TypeSpecifier *p2)
{
  ident_ = p1;
  typespecifier_ = p2;

}

FP::FP(const FP & other)
{
  ident_ = other.ident_;
  typespecifier_ = other.typespecifier_->clone();

}

FP &FP::operator=(const FP & other)
{
  FP tmp(other);
  swap(tmp);
  return *this;
}

void FP::swap(FP & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typespecifier_, other.typespecifier_);

}

FP::~FP()
{
  delete(typespecifier_);

}

void FP::accept(Visitor *v)
{
  v->visitFP(this);
}

FP *FP::clone() const
{
  return new FP(*this);
}



/********************   TSsimple    ********************/
TSsimple::TSsimple(SimpleTypeSpecifier *p1)
{
  simpletypespecifier_ = p1;

}

TSsimple::TSsimple(const TSsimple & other)
{
  simpletypespecifier_ = other.simpletypespecifier_->clone();

}

TSsimple &TSsimple::operator=(const TSsimple & other)
{
  TSsimple tmp(other);
  swap(tmp);
  return *this;
}

void TSsimple::swap(TSsimple & other)
{
  std::swap(simpletypespecifier_, other.simpletypespecifier_);

}

TSsimple::~TSsimple()
{
  delete(simpletypespecifier_);

}

void TSsimple::accept(Visitor *v)
{
  v->visitTSsimple(this);
}

TSsimple *TSsimple::clone() const
{
  return new TSsimple(*this);
}



/********************   TScoll    ********************/
TScoll::TScoll(CollectionType *p1)
{
  collectiontype_ = p1;

}

TScoll::TScoll(const TScoll & other)
{
  collectiontype_ = other.collectiontype_->clone();

}

TScoll &TScoll::operator=(const TScoll & other)
{
  TScoll tmp(other);
  swap(tmp);
  return *this;
}

void TScoll::swap(TScoll & other)
{
  std::swap(collectiontype_, other.collectiontype_);

}

TScoll::~TScoll()
{
  delete(collectiontype_);

}

void TScoll::accept(Visitor *v)
{
  v->visitTScoll(this);
}

TScoll *TScoll::clone() const
{
  return new TScoll(*this);
}



/********************   CT    ********************/
CT::CT(CollectionKind *p1, SimpleTypeSpecifier *p2)
{
  collectionkind_ = p1;
  simpletypespecifier_ = p2;

}

CT::CT(const CT & other)
{
  collectionkind_ = other.collectionkind_->clone();
  simpletypespecifier_ = other.simpletypespecifier_->clone();

}

CT &CT::operator=(const CT & other)
{
  CT tmp(other);
  swap(tmp);
  return *this;
}

void CT::swap(CT & other)
{
  std::swap(collectionkind_, other.collectionkind_);
  std::swap(simpletypespecifier_, other.simpletypespecifier_);

}

CT::~CT()
{
  delete(collectionkind_);
  delete(simpletypespecifier_);

}

void CT::accept(Visitor *v)
{
  v->visitCT(this);
}

CT *CT::clone() const
{
  return new CT(*this);
}



/********************   RT    ********************/
RT::RT(TypeSpecifier *p1)
{
  typespecifier_ = p1;

}

RT::RT(const RT & other)
{
  typespecifier_ = other.typespecifier_->clone();

}

RT &RT::operator=(const RT & other)
{
  RT tmp(other);
  swap(tmp);
  return *this;
}

void RT::swap(RT & other)
{
  std::swap(typespecifier_, other.typespecifier_);

}

RT::~RT()
{
  delete(typespecifier_);

}

void RT::accept(Visitor *v)
{
  v->visitRT(this);
}

RT *RT::clone() const
{
  return new RT(*this);
}



/********************   OCLExp    ********************/
OCLExp::OCLExp(Expression *p1)
{
  expression_ = p1;

}

OCLExp::OCLExp(const OCLExp & other)
{
  expression_ = other.expression_->clone();

}

OCLExp &OCLExp::operator=(const OCLExp & other)
{
  OCLExp tmp(other);
  swap(tmp);
  return *this;
}

void OCLExp::swap(OCLExp & other)
{
  std::swap(expression_, other.expression_);

}

OCLExp::~OCLExp()
{
  delete(expression_);

}

void OCLExp::accept(Visitor *v)
{
  v->visitOCLExp(this);
}

OCLExp *OCLExp::clone() const
{
  return new OCLExp(*this);
}



/********************   OCLExpLet    ********************/
OCLExpLet::OCLExpLet(ListLetExpression *p1, Expression *p2)
{
  listletexpression_ = p1;
  expression_ = p2;

}

OCLExpLet::OCLExpLet(const OCLExpLet & other)
{
  listletexpression_ = other.listletexpression_->clone();
  expression_ = other.expression_->clone();

}

OCLExpLet &OCLExpLet::operator=(const OCLExpLet & other)
{
  OCLExpLet tmp(other);
  swap(tmp);
  return *this;
}

void OCLExpLet::swap(OCLExpLet & other)
{
  std::swap(listletexpression_, other.listletexpression_);
  std::swap(expression_, other.expression_);

}

OCLExpLet::~OCLExpLet()
{
  delete(listletexpression_);
  delete(expression_);

}

void OCLExpLet::accept(Visitor *v)
{
  v->visitOCLExpLet(this);
}

OCLExpLet *OCLExpLet::clone() const
{
  return new OCLExpLet(*this);
}



/********************   LENoParam    ********************/
LENoParam::LENoParam(Ident p1, Expression *p2)
{
  ident_ = p1;
  expression_ = p2;

}

LENoParam::LENoParam(const LENoParam & other)
{
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}

LENoParam &LENoParam::operator=(const LENoParam & other)
{
  LENoParam tmp(other);
  swap(tmp);
  return *this;
}

void LENoParam::swap(LENoParam & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

LENoParam::~LENoParam()
{
  delete(expression_);

}

void LENoParam::accept(Visitor *v)
{
  v->visitLENoParam(this);
}

LENoParam *LENoParam::clone() const
{
  return new LENoParam(*this);
}



/********************   LENoParamType    ********************/
LENoParamType::LENoParamType(Ident p1, TypeSpecifier *p2, Expression *p3)
{
  ident_ = p1;
  typespecifier_ = p2;
  expression_ = p3;

}

LENoParamType::LENoParamType(const LENoParamType & other)
{
  ident_ = other.ident_;
  typespecifier_ = other.typespecifier_->clone();
  expression_ = other.expression_->clone();

}

LENoParamType &LENoParamType::operator=(const LENoParamType & other)
{
  LENoParamType tmp(other);
  swap(tmp);
  return *this;
}

void LENoParamType::swap(LENoParamType & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(expression_, other.expression_);

}

LENoParamType::~LENoParamType()
{
  delete(typespecifier_);
  delete(expression_);

}

void LENoParamType::accept(Visitor *v)
{
  v->visitLENoParamType(this);
}

LENoParamType *LENoParamType::clone() const
{
  return new LENoParamType(*this);
}



/********************   LE    ********************/
LE::LE(Ident p1, ListFormalParameter *p2, Expression *p3)
{
  ident_ = p1;
  listformalparameter_ = p2;
  expression_ = p3;

}

LE::LE(const LE & other)
{
  ident_ = other.ident_;
  listformalparameter_ = other.listformalparameter_->clone();
  expression_ = other.expression_->clone();

}

LE &LE::operator=(const LE & other)
{
  LE tmp(other);
  swap(tmp);
  return *this;
}

void LE::swap(LE & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listformalparameter_, other.listformalparameter_);
  std::swap(expression_, other.expression_);

}

LE::~LE()
{
  delete(listformalparameter_);
  delete(expression_);

}

void LE::accept(Visitor *v)
{
  v->visitLE(this);
}

LE *LE::clone() const
{
  return new LE(*this);
}



/********************   LEType    ********************/
LEType::LEType(Ident p1, ListFormalParameter *p2, TypeSpecifier *p3, Expression *p4)
{
  ident_ = p1;
  listformalparameter_ = p2;
  typespecifier_ = p3;
  expression_ = p4;

}

LEType::LEType(const LEType & other)
{
  ident_ = other.ident_;
  listformalparameter_ = other.listformalparameter_->clone();
  typespecifier_ = other.typespecifier_->clone();
  expression_ = other.expression_->clone();

}

LEType &LEType::operator=(const LEType & other)
{
  LEType tmp(other);
  swap(tmp);
  return *this;
}

void LEType::swap(LEType & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listformalparameter_, other.listformalparameter_);
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(expression_, other.expression_);

}

LEType::~LEType()
{
  delete(listformalparameter_);
  delete(typespecifier_);
  delete(expression_);

}

void LEType::accept(Visitor *v)
{
  v->visitLEType(this);
}

LEType *LEType::clone() const
{
  return new LEType(*this);
}



/********************   IfExp    ********************/
IfExp::IfExp(Expression *p1, Expression *p2, Expression *p3)
{
  expression_1 = p1;
  expression_2 = p2;
  expression_3 = p3;

}

IfExp::IfExp(const IfExp & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  expression_3 = other.expression_3->clone();

}

IfExp &IfExp::operator=(const IfExp & other)
{
  IfExp tmp(other);
  swap(tmp);
  return *this;
}

void IfExp::swap(IfExp & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(expression_3, other.expression_3);

}

IfExp::~IfExp()
{
  delete(expression_1);
  delete(expression_2);
  delete(expression_3);

}

void IfExp::accept(Visitor *v)
{
  v->visitIfExp(this);
}

IfExp *IfExp::clone() const
{
  return new IfExp(*this);
}



/********************   EOpImpl    ********************/
EOpImpl::EOpImpl(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EOpImpl::EOpImpl(const EOpImpl & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EOpImpl &EOpImpl::operator=(const EOpImpl & other)
{
  EOpImpl tmp(other);
  swap(tmp);
  return *this;
}

void EOpImpl::swap(EOpImpl & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EOpImpl::~EOpImpl()
{
  delete(expression_1);
  delete(expression_2);

}

void EOpImpl::accept(Visitor *v)
{
  v->visitEOpImpl(this);
}

EOpImpl *EOpImpl::clone() const
{
  return new EOpImpl(*this);
}



/********************   EOpLog    ********************/
EOpLog::EOpLog(Expression *p1, LogicalOperator *p2, Expression *p3)
{
  expression_1 = p1;
  logicaloperator_ = p2;
  expression_2 = p3;

}

EOpLog::EOpLog(const EOpLog & other)
{
  expression_1 = other.expression_1->clone();
  logicaloperator_ = other.logicaloperator_->clone();
  expression_2 = other.expression_2->clone();

}

EOpLog &EOpLog::operator=(const EOpLog & other)
{
  EOpLog tmp(other);
  swap(tmp);
  return *this;
}

void EOpLog::swap(EOpLog & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(logicaloperator_, other.logicaloperator_);
  std::swap(expression_2, other.expression_2);

}

EOpLog::~EOpLog()
{
  delete(expression_1);
  delete(logicaloperator_);
  delete(expression_2);

}

void EOpLog::accept(Visitor *v)
{
  v->visitEOpLog(this);
}

EOpLog *EOpLog::clone() const
{
  return new EOpLog(*this);
}



/********************   EOpEq    ********************/
EOpEq::EOpEq(Expression *p1, EqualityOperator *p2, Expression *p3)
{
  expression_1 = p1;
  equalityoperator_ = p2;
  expression_2 = p3;

}

EOpEq::EOpEq(const EOpEq & other)
{
  expression_1 = other.expression_1->clone();
  equalityoperator_ = other.equalityoperator_->clone();
  expression_2 = other.expression_2->clone();

}

EOpEq &EOpEq::operator=(const EOpEq & other)
{
  EOpEq tmp(other);
  swap(tmp);
  return *this;
}

void EOpEq::swap(EOpEq & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(equalityoperator_, other.equalityoperator_);
  std::swap(expression_2, other.expression_2);

}

EOpEq::~EOpEq()
{
  delete(expression_1);
  delete(equalityoperator_);
  delete(expression_2);

}

void EOpEq::accept(Visitor *v)
{
  v->visitEOpEq(this);
}

EOpEq *EOpEq::clone() const
{
  return new EOpEq(*this);
}



/********************   EOpRel    ********************/
EOpRel::EOpRel(Expression *p1, RelationalOperator *p2, Expression *p3)
{
  expression_1 = p1;
  relationaloperator_ = p2;
  expression_2 = p3;

}

EOpRel::EOpRel(const EOpRel & other)
{
  expression_1 = other.expression_1->clone();
  relationaloperator_ = other.relationaloperator_->clone();
  expression_2 = other.expression_2->clone();

}

EOpRel &EOpRel::operator=(const EOpRel & other)
{
  EOpRel tmp(other);
  swap(tmp);
  return *this;
}

void EOpRel::swap(EOpRel & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(relationaloperator_, other.relationaloperator_);
  std::swap(expression_2, other.expression_2);

}

EOpRel::~EOpRel()
{
  delete(expression_1);
  delete(relationaloperator_);
  delete(expression_2);

}

void EOpRel::accept(Visitor *v)
{
  v->visitEOpRel(this);
}

EOpRel *EOpRel::clone() const
{
  return new EOpRel(*this);
}



/********************   EOpAdd    ********************/
EOpAdd::EOpAdd(Expression *p1, AddOperator *p2, Expression *p3)
{
  expression_1 = p1;
  addoperator_ = p2;
  expression_2 = p3;

}

EOpAdd::EOpAdd(const EOpAdd & other)
{
  expression_1 = other.expression_1->clone();
  addoperator_ = other.addoperator_->clone();
  expression_2 = other.expression_2->clone();

}

EOpAdd &EOpAdd::operator=(const EOpAdd & other)
{
  EOpAdd tmp(other);
  swap(tmp);
  return *this;
}

void EOpAdd::swap(EOpAdd & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(addoperator_, other.addoperator_);
  std::swap(expression_2, other.expression_2);

}

EOpAdd::~EOpAdd()
{
  delete(expression_1);
  delete(addoperator_);
  delete(expression_2);

}

void EOpAdd::accept(Visitor *v)
{
  v->visitEOpAdd(this);
}

EOpAdd *EOpAdd::clone() const
{
  return new EOpAdd(*this);
}



/********************   EOpMul    ********************/
EOpMul::EOpMul(Expression *p1, MultiplyOperator *p2, Expression *p3)
{
  expression_1 = p1;
  multiplyoperator_ = p2;
  expression_2 = p3;

}

EOpMul::EOpMul(const EOpMul & other)
{
  expression_1 = other.expression_1->clone();
  multiplyoperator_ = other.multiplyoperator_->clone();
  expression_2 = other.expression_2->clone();

}

EOpMul &EOpMul::operator=(const EOpMul & other)
{
  EOpMul tmp(other);
  swap(tmp);
  return *this;
}

void EOpMul::swap(EOpMul & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(multiplyoperator_, other.multiplyoperator_);
  std::swap(expression_2, other.expression_2);

}

EOpMul::~EOpMul()
{
  delete(expression_1);
  delete(multiplyoperator_);
  delete(expression_2);

}

void EOpMul::accept(Visitor *v)
{
  v->visitEOpMul(this);
}

EOpMul *EOpMul::clone() const
{
  return new EOpMul(*this);
}



/********************   EOpUn    ********************/
EOpUn::EOpUn(UnaryOperator *p1, Expression *p2)
{
  unaryoperator_ = p1;
  expression_ = p2;

}

EOpUn::EOpUn(const EOpUn & other)
{
  unaryoperator_ = other.unaryoperator_->clone();
  expression_ = other.expression_->clone();

}

EOpUn &EOpUn::operator=(const EOpUn & other)
{
  EOpUn tmp(other);
  swap(tmp);
  return *this;
}

void EOpUn::swap(EOpUn & other)
{
  std::swap(unaryoperator_, other.unaryoperator_);
  std::swap(expression_, other.expression_);

}

EOpUn::~EOpUn()
{
  delete(unaryoperator_);
  delete(expression_);

}

void EOpUn::accept(Visitor *v)
{
  v->visitEOpUn(this);
}

EOpUn *EOpUn::clone() const
{
  return new EOpUn(*this);
}



/********************   EExplPropCall    ********************/
EExplPropCall::EExplPropCall(Expression *p1, PostfixOperator *p2, PropertyCall *p3)
{
  expression_ = p1;
  postfixoperator_ = p2;
  propertycall_ = p3;

}

EExplPropCall::EExplPropCall(const EExplPropCall & other)
{
  expression_ = other.expression_->clone();
  postfixoperator_ = other.postfixoperator_->clone();
  propertycall_ = other.propertycall_->clone();

}

EExplPropCall &EExplPropCall::operator=(const EExplPropCall & other)
{
  EExplPropCall tmp(other);
  swap(tmp);
  return *this;
}

void EExplPropCall::swap(EExplPropCall & other)
{
  std::swap(expression_, other.expression_);
  std::swap(postfixoperator_, other.postfixoperator_);
  std::swap(propertycall_, other.propertycall_);

}

EExplPropCall::~EExplPropCall()
{
  delete(expression_);
  delete(postfixoperator_);
  delete(propertycall_);

}

void EExplPropCall::accept(Visitor *v)
{
  v->visitEExplPropCall(this);
}

EExplPropCall *EExplPropCall::clone() const
{
  return new EExplPropCall(*this);
}



/********************   EMessage    ********************/
EMessage::EMessage(Expression *p1, PathName *p2, ListMessageArg *p3)
{
  expression_ = p1;
  pathname_ = p2;
  listmessagearg_ = p3;

}

EMessage::EMessage(const EMessage & other)
{
  expression_ = other.expression_->clone();
  pathname_ = other.pathname_->clone();
  listmessagearg_ = other.listmessagearg_->clone();

}

EMessage &EMessage::operator=(const EMessage & other)
{
  EMessage tmp(other);
  swap(tmp);
  return *this;
}

void EMessage::swap(EMessage & other)
{
  std::swap(expression_, other.expression_);
  std::swap(pathname_, other.pathname_);
  std::swap(listmessagearg_, other.listmessagearg_);

}

EMessage::~EMessage()
{
  delete(expression_);
  delete(pathname_);
  delete(listmessagearg_);

}

void EMessage::accept(Visitor *v)
{
  v->visitEMessage(this);
}

EMessage *EMessage::clone() const
{
  return new EMessage(*this);
}



/********************   EImplPropCall    ********************/
EImplPropCall::EImplPropCall(PropertyCall *p1)
{
  propertycall_ = p1;

}

EImplPropCall::EImplPropCall(const EImplPropCall & other)
{
  propertycall_ = other.propertycall_->clone();

}

EImplPropCall &EImplPropCall::operator=(const EImplPropCall & other)
{
  EImplPropCall tmp(other);
  swap(tmp);
  return *this;
}

void EImplPropCall::swap(EImplPropCall & other)
{
  std::swap(propertycall_, other.propertycall_);

}

EImplPropCall::~EImplPropCall()
{
  delete(propertycall_);

}

void EImplPropCall::accept(Visitor *v)
{
  v->visitEImplPropCall(this);
}

EImplPropCall *EImplPropCall::clone() const
{
  return new EImplPropCall(*this);
}



/********************   ELitColl    ********************/
ELitColl::ELitColl(LiteralCollection *p1)
{
  literalcollection_ = p1;

}

ELitColl::ELitColl(const ELitColl & other)
{
  literalcollection_ = other.literalcollection_->clone();

}

ELitColl &ELitColl::operator=(const ELitColl & other)
{
  ELitColl tmp(other);
  swap(tmp);
  return *this;
}

void ELitColl::swap(ELitColl & other)
{
  std::swap(literalcollection_, other.literalcollection_);

}

ELitColl::~ELitColl()
{
  delete(literalcollection_);

}

void ELitColl::accept(Visitor *v)
{
  v->visitELitColl(this);
}

ELitColl *ELitColl::clone() const
{
  return new ELitColl(*this);
}



/********************   ELit    ********************/
ELit::ELit(OCLLiteral *p1)
{
  oclliteral_ = p1;

}

ELit::ELit(const ELit & other)
{
  oclliteral_ = other.oclliteral_->clone();

}

ELit &ELit::operator=(const ELit & other)
{
  ELit tmp(other);
  swap(tmp);
  return *this;
}

void ELit::swap(ELit & other)
{
  std::swap(oclliteral_, other.oclliteral_);

}

ELit::~ELit()
{
  delete(oclliteral_);

}

void ELit::accept(Visitor *v)
{
  v->visitELit(this);
}

ELit *ELit::clone() const
{
  return new ELit(*this);
}



/********************   EIfExp    ********************/
EIfExp::EIfExp(IfExpression *p1)
{
  ifexpression_ = p1;

}

EIfExp::EIfExp(const EIfExp & other)
{
  ifexpression_ = other.ifexpression_->clone();

}

EIfExp &EIfExp::operator=(const EIfExp & other)
{
  EIfExp tmp(other);
  swap(tmp);
  return *this;
}

void EIfExp::swap(EIfExp & other)
{
  std::swap(ifexpression_, other.ifexpression_);

}

EIfExp::~EIfExp()
{
  delete(ifexpression_);

}

void EIfExp::accept(Visitor *v)
{
  v->visitEIfExp(this);
}

EIfExp *EIfExp::clone() const
{
  return new EIfExp(*this);
}



/********************   ENull    ********************/
ENull::ENull()
{

}

ENull::ENull(const ENull & other)
{

}

ENull &ENull::operator=(const ENull & other)
{
  ENull tmp(other);
  swap(tmp);
  return *this;
}

void ENull::swap(ENull & other)
{

}

ENull::~ENull()
{

}

void ENull::accept(Visitor *v)
{
  v->visitENull(this);
}

ENull *ENull::clone() const
{
  return new ENull(*this);
}



/********************   MAExpr    ********************/
MAExpr::MAExpr(Expression *p1)
{
  expression_ = p1;

}

MAExpr::MAExpr(const MAExpr & other)
{
  expression_ = other.expression_->clone();

}

MAExpr &MAExpr::operator=(const MAExpr & other)
{
  MAExpr tmp(other);
  swap(tmp);
  return *this;
}

void MAExpr::swap(MAExpr & other)
{
  std::swap(expression_, other.expression_);

}

MAExpr::~MAExpr()
{
  delete(expression_);

}

void MAExpr::accept(Visitor *v)
{
  v->visitMAExpr(this);
}

MAExpr *MAExpr::clone() const
{
  return new MAExpr(*this);
}



/********************   MAUnspec    ********************/
MAUnspec::MAUnspec()
{

}

MAUnspec::MAUnspec(const MAUnspec & other)
{

}

MAUnspec &MAUnspec::operator=(const MAUnspec & other)
{
  MAUnspec tmp(other);
  swap(tmp);
  return *this;
}

void MAUnspec::swap(MAUnspec & other)
{

}

MAUnspec::~MAUnspec()
{

}

void MAUnspec::accept(Visitor *v)
{
  v->visitMAUnspec(this);
}

MAUnspec *MAUnspec::clone() const
{
  return new MAUnspec(*this);
}



/********************   MAUnspecTyped    ********************/
MAUnspecTyped::MAUnspecTyped(TypeSpecifier *p1)
{
  typespecifier_ = p1;

}

MAUnspecTyped::MAUnspecTyped(const MAUnspecTyped & other)
{
  typespecifier_ = other.typespecifier_->clone();

}

MAUnspecTyped &MAUnspecTyped::operator=(const MAUnspecTyped & other)
{
  MAUnspecTyped tmp(other);
  swap(tmp);
  return *this;
}

void MAUnspecTyped::swap(MAUnspecTyped & other)
{
  std::swap(typespecifier_, other.typespecifier_);

}

MAUnspecTyped::~MAUnspecTyped()
{
  delete(typespecifier_);

}

void MAUnspecTyped::accept(Visitor *v)
{
  v->visitMAUnspecTyped(this);
}

MAUnspecTyped *MAUnspecTyped::clone() const
{
  return new MAUnspecTyped(*this);
}



/********************   PCall    ********************/
PCall::PCall(PathName *p1, PossTimeExpression *p2, PossQualifiers *p3, PossPropCallParam *p4)
{
  pathname_ = p1;
  posstimeexpression_ = p2;
  possqualifiers_ = p3;
  posspropcallparam_ = p4;

}

PCall::PCall(const PCall & other)
{
  pathname_ = other.pathname_->clone();
  posstimeexpression_ = other.posstimeexpression_->clone();
  possqualifiers_ = other.possqualifiers_->clone();
  posspropcallparam_ = other.posspropcallparam_->clone();

}

PCall &PCall::operator=(const PCall & other)
{
  PCall tmp(other);
  swap(tmp);
  return *this;
}

void PCall::swap(PCall & other)
{
  std::swap(pathname_, other.pathname_);
  std::swap(posstimeexpression_, other.posstimeexpression_);
  std::swap(possqualifiers_, other.possqualifiers_);
  std::swap(posspropcallparam_, other.posspropcallparam_);

}

PCall::~PCall()
{
  delete(pathname_);
  delete(posstimeexpression_);
  delete(possqualifiers_);
  delete(posspropcallparam_);

}

void PCall::accept(Visitor *v)
{
  v->visitPCall(this);
}

PCall *PCall::clone() const
{
  return new PCall(*this);
}



/********************   PathN    ********************/
PathN::PathN(ListPName *p1)
{
  listpname_ = p1;

}

PathN::PathN(const PathN & other)
{
  listpname_ = other.listpname_->clone();

}

PathN &PathN::operator=(const PathN & other)
{
  PathN tmp(other);
  swap(tmp);
  return *this;
}

void PathN::swap(PathN & other)
{
  std::swap(listpname_, other.listpname_);

}

PathN::~PathN()
{
  delete(listpname_);

}

void PathN::accept(Visitor *v)
{
  v->visitPathN(this);
}

PathN *PathN::clone() const
{
  return new PathN(*this);
}



/********************   PN    ********************/
PN::PN(Ident p1)
{
  ident_ = p1;

}

PN::PN(const PN & other)
{
  ident_ = other.ident_;

}

PN &PN::operator=(const PN & other)
{
  PN tmp(other);
  swap(tmp);
  return *this;
}

void PN::swap(PN & other)
{
  std::swap(ident_, other.ident_);

}

PN::~PN()
{

}

void PN::accept(Visitor *v)
{
  v->visitPN(this);
}

PN *PN::clone() const
{
  return new PN(*this);
}



/********************   NoQual    ********************/
NoQual::NoQual()
{

}

NoQual::NoQual(const NoQual & other)
{

}

NoQual &NoQual::operator=(const NoQual & other)
{
  NoQual tmp(other);
  swap(tmp);
  return *this;
}

void NoQual::swap(NoQual & other)
{

}

NoQual::~NoQual()
{

}

void NoQual::accept(Visitor *v)
{
  v->visitNoQual(this);
}

NoQual *NoQual::clone() const
{
  return new NoQual(*this);
}



/********************   Qual    ********************/
Qual::Qual(Qualifiers *p1)
{
  qualifiers_ = p1;

}

Qual::Qual(const Qual & other)
{
  qualifiers_ = other.qualifiers_->clone();

}

Qual &Qual::operator=(const Qual & other)
{
  Qual tmp(other);
  swap(tmp);
  return *this;
}

void Qual::swap(Qual & other)
{
  std::swap(qualifiers_, other.qualifiers_);

}

Qual::~Qual()
{
  delete(qualifiers_);

}

void Qual::accept(Visitor *v)
{
  v->visitQual(this);
}

Qual *Qual::clone() const
{
  return new Qual(*this);
}



/********************   Quals    ********************/
Quals::Quals(ListExpression *p1)
{
  listexpression_ = p1;

}

Quals::Quals(const Quals & other)
{
  listexpression_ = other.listexpression_->clone();

}

Quals &Quals::operator=(const Quals & other)
{
  Quals tmp(other);
  swap(tmp);
  return *this;
}

void Quals::swap(Quals & other)
{
  std::swap(listexpression_, other.listexpression_);

}

Quals::~Quals()
{
  delete(listexpression_);

}

void Quals::accept(Visitor *v)
{
  v->visitQuals(this);
}

Quals *Quals::clone() const
{
  return new Quals(*this);
}



/********************   NoTE    ********************/
NoTE::NoTE()
{

}

NoTE::NoTE(const NoTE & other)
{

}

NoTE &NoTE::operator=(const NoTE & other)
{
  NoTE tmp(other);
  swap(tmp);
  return *this;
}

void NoTE::swap(NoTE & other)
{

}

NoTE::~NoTE()
{

}

void NoTE::accept(Visitor *v)
{
  v->visitNoTE(this);
}

NoTE *NoTE::clone() const
{
  return new NoTE(*this);
}



/********************   AtPre    ********************/
AtPre::AtPre()
{

}

AtPre::AtPre(const AtPre & other)
{

}

AtPre &AtPre::operator=(const AtPre & other)
{
  AtPre tmp(other);
  swap(tmp);
  return *this;
}

void AtPre::swap(AtPre & other)
{

}

AtPre::~AtPre()
{

}

void AtPre::accept(Visitor *v)
{
  v->visitAtPre(this);
}

AtPre *AtPre::clone() const
{
  return new AtPre(*this);
}



/********************   NoPCP    ********************/
NoPCP::NoPCP()
{

}

NoPCP::NoPCP(const NoPCP & other)
{

}

NoPCP &NoPCP::operator=(const NoPCP & other)
{
  NoPCP tmp(other);
  swap(tmp);
  return *this;
}

void NoPCP::swap(NoPCP & other)
{

}

NoPCP::~NoPCP()
{

}

void NoPCP::accept(Visitor *v)
{
  v->visitNoPCP(this);
}

NoPCP *NoPCP::clone() const
{
  return new NoPCP(*this);
}



/********************   PCPs    ********************/
PCPs::PCPs(PropertyCallParameters *p1)
{
  propertycallparameters_ = p1;

}

PCPs::PCPs(const PCPs & other)
{
  propertycallparameters_ = other.propertycallparameters_->clone();

}

PCPs &PCPs::operator=(const PCPs & other)
{
  PCPs tmp(other);
  swap(tmp);
  return *this;
}

void PCPs::swap(PCPs & other)
{
  std::swap(propertycallparameters_, other.propertycallparameters_);

}

PCPs::~PCPs()
{
  delete(propertycallparameters_);

}

void PCPs::accept(Visitor *v)
{
  v->visitPCPs(this);
}

PCPs *PCPs::clone() const
{
  return new PCPs(*this);
}



/********************   Decl    ********************/
Decl::Decl(DeclaratorVarList *p1)
{
  declaratorvarlist_ = p1;

}

Decl::Decl(const Decl & other)
{
  declaratorvarlist_ = other.declaratorvarlist_->clone();

}

Decl &Decl::operator=(const Decl & other)
{
  Decl tmp(other);
  swap(tmp);
  return *this;
}

void Decl::swap(Decl & other)
{
  std::swap(declaratorvarlist_, other.declaratorvarlist_);

}

Decl::~Decl()
{
  delete(declaratorvarlist_);

}

void Decl::accept(Visitor *v)
{
  v->visitDecl(this);
}

Decl *Decl::clone() const
{
  return new Decl(*this);
}



/********************   DeclAcc    ********************/
DeclAcc::DeclAcc(DeclaratorVarList *p1, Ident p2, TypeSpecifier *p3, Expression *p4)
{
  declaratorvarlist_ = p1;
  ident_ = p2;
  typespecifier_ = p3;
  expression_ = p4;

}

DeclAcc::DeclAcc(const DeclAcc & other)
{
  declaratorvarlist_ = other.declaratorvarlist_->clone();
  ident_ = other.ident_;
  typespecifier_ = other.typespecifier_->clone();
  expression_ = other.expression_->clone();

}

DeclAcc &DeclAcc::operator=(const DeclAcc & other)
{
  DeclAcc tmp(other);
  swap(tmp);
  return *this;
}

void DeclAcc::swap(DeclAcc & other)
{
  std::swap(declaratorvarlist_, other.declaratorvarlist_);
  std::swap(ident_, other.ident_);
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(expression_, other.expression_);

}

DeclAcc::~DeclAcc()
{
  delete(declaratorvarlist_);
  delete(typespecifier_);
  delete(expression_);

}

void DeclAcc::accept(Visitor *v)
{
  v->visitDeclAcc(this);
}

DeclAcc *DeclAcc::clone() const
{
  return new DeclAcc(*this);
}



/********************   DVL    ********************/
DVL::DVL(ListIdent *p1)
{
  listident_ = p1;

}

DVL::DVL(const DVL & other)
{
  listident_ = other.listident_->clone();

}

DVL &DVL::operator=(const DVL & other)
{
  DVL tmp(other);
  swap(tmp);
  return *this;
}

void DVL::swap(DVL & other)
{
  std::swap(listident_, other.listident_);

}

DVL::~DVL()
{
  delete(listident_);

}

void DVL::accept(Visitor *v)
{
  v->visitDVL(this);
}

DVL *DVL::clone() const
{
  return new DVL(*this);
}



/********************   DVLType    ********************/
DVLType::DVLType(ListIdent *p1, SimpleTypeSpecifier *p2)
{
  listident_ = p1;
  simpletypespecifier_ = p2;

}

DVLType::DVLType(const DVLType & other)
{
  listident_ = other.listident_->clone();
  simpletypespecifier_ = other.simpletypespecifier_->clone();

}

DVLType &DVLType::operator=(const DVLType & other)
{
  DVLType tmp(other);
  swap(tmp);
  return *this;
}

void DVLType::swap(DVLType & other)
{
  std::swap(listident_, other.listident_);
  std::swap(simpletypespecifier_, other.simpletypespecifier_);

}

DVLType::~DVLType()
{
  delete(listident_);
  delete(simpletypespecifier_);

}

void DVLType::accept(Visitor *v)
{
  v->visitDVLType(this);
}

DVLType *DVLType::clone() const
{
  return new DVLType(*this);
}



/********************   PCPDecl    ********************/
PCPDecl::PCPDecl(Declarator *p1, ListExpression *p2)
{
  declarator_ = p1;
  listexpression_ = p2;

}

PCPDecl::PCPDecl(const PCPDecl & other)
{
  declarator_ = other.declarator_->clone();
  listexpression_ = other.listexpression_->clone();

}

PCPDecl &PCPDecl::operator=(const PCPDecl & other)
{
  PCPDecl tmp(other);
  swap(tmp);
  return *this;
}

void PCPDecl::swap(PCPDecl & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(listexpression_, other.listexpression_);

}

PCPDecl::~PCPDecl()
{
  delete(declarator_);
  delete(listexpression_);

}

void PCPDecl::accept(Visitor *v)
{
  v->visitPCPDecl(this);
}

PCPDecl *PCPDecl::clone() const
{
  return new PCPDecl(*this);
}



/********************   PCP    ********************/
PCP::PCP(ListExpression *p1)
{
  listexpression_ = p1;

}

PCP::PCP(const PCP & other)
{
  listexpression_ = other.listexpression_->clone();

}

PCP &PCP::operator=(const PCP & other)
{
  PCP tmp(other);
  swap(tmp);
  return *this;
}

void PCP::swap(PCP & other)
{
  std::swap(listexpression_, other.listexpression_);

}

PCP::~PCP()
{
  delete(listexpression_);

}

void PCP::accept(Visitor *v)
{
  v->visitPCP(this);
}

PCP *PCP::clone() const
{
  return new PCP(*this);
}



/********************   PCPNoDeclNoParam    ********************/
PCPNoDeclNoParam::PCPNoDeclNoParam()
{

}

PCPNoDeclNoParam::PCPNoDeclNoParam(const PCPNoDeclNoParam & other)
{

}

PCPNoDeclNoParam &PCPNoDeclNoParam::operator=(const PCPNoDeclNoParam & other)
{
  PCPNoDeclNoParam tmp(other);
  swap(tmp);
  return *this;
}

void PCPNoDeclNoParam::swap(PCPNoDeclNoParam & other)
{

}

PCPNoDeclNoParam::~PCPNoDeclNoParam()
{

}

void PCPNoDeclNoParam::accept(Visitor *v)
{
  v->visitPCPNoDeclNoParam(this);
}

PCPNoDeclNoParam *PCPNoDeclNoParam::clone() const
{
  return new PCPNoDeclNoParam(*this);
}



/********************   PCPConcrete    ********************/
PCPConcrete::PCPConcrete(Expression *p1, ListPCPHelper *p2)
{
  expression_ = p1;
  listpcphelper_ = p2;

}

PCPConcrete::PCPConcrete(const PCPConcrete & other)
{
  expression_ = other.expression_->clone();
  listpcphelper_ = other.listpcphelper_->clone();

}

PCPConcrete &PCPConcrete::operator=(const PCPConcrete & other)
{
  PCPConcrete tmp(other);
  swap(tmp);
  return *this;
}

void PCPConcrete::swap(PCPConcrete & other)
{
  std::swap(expression_, other.expression_);
  std::swap(listpcphelper_, other.listpcphelper_);

}

PCPConcrete::~PCPConcrete()
{
  delete(expression_);
  delete(listpcphelper_);

}

void PCPConcrete::accept(Visitor *v)
{
  v->visitPCPConcrete(this);
}

PCPConcrete *PCPConcrete::clone() const
{
  return new PCPConcrete(*this);
}



/********************   PCPComma    ********************/
PCPComma::PCPComma(Expression *p1)
{
  expression_ = p1;

}

PCPComma::PCPComma(const PCPComma & other)
{
  expression_ = other.expression_->clone();

}

PCPComma &PCPComma::operator=(const PCPComma & other)
{
  PCPComma tmp(other);
  swap(tmp);
  return *this;
}

void PCPComma::swap(PCPComma & other)
{
  std::swap(expression_, other.expression_);

}

PCPComma::~PCPComma()
{
  delete(expression_);

}

void PCPComma::accept(Visitor *v)
{
  v->visitPCPComma(this);
}

PCPComma *PCPComma::clone() const
{
  return new PCPComma(*this);
}



/********************   PCPColon    ********************/
PCPColon::PCPColon(SimpleTypeSpecifier *p1)
{
  simpletypespecifier_ = p1;

}

PCPColon::PCPColon(const PCPColon & other)
{
  simpletypespecifier_ = other.simpletypespecifier_->clone();

}

PCPColon &PCPColon::operator=(const PCPColon & other)
{
  PCPColon tmp(other);
  swap(tmp);
  return *this;
}

void PCPColon::swap(PCPColon & other)
{
  std::swap(simpletypespecifier_, other.simpletypespecifier_);

}

PCPColon::~PCPColon()
{
  delete(simpletypespecifier_);

}

void PCPColon::accept(Visitor *v)
{
  v->visitPCPColon(this);
}

PCPColon *PCPColon::clone() const
{
  return new PCPColon(*this);
}



/********************   PCPIterate    ********************/
PCPIterate::PCPIterate(Ident p1, TypeSpecifier *p2, Expression *p3)
{
  ident_ = p1;
  typespecifier_ = p2;
  expression_ = p3;

}

PCPIterate::PCPIterate(const PCPIterate & other)
{
  ident_ = other.ident_;
  typespecifier_ = other.typespecifier_->clone();
  expression_ = other.expression_->clone();

}

PCPIterate &PCPIterate::operator=(const PCPIterate & other)
{
  PCPIterate tmp(other);
  swap(tmp);
  return *this;
}

void PCPIterate::swap(PCPIterate & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typespecifier_, other.typespecifier_);
  std::swap(expression_, other.expression_);

}

PCPIterate::~PCPIterate()
{
  delete(typespecifier_);
  delete(expression_);

}

void PCPIterate::accept(Visitor *v)
{
  v->visitPCPIterate(this);
}

PCPIterate *PCPIterate::clone() const
{
  return new PCPIterate(*this);
}



/********************   PCPBar    ********************/
PCPBar::PCPBar(Expression *p1)
{
  expression_ = p1;

}

PCPBar::PCPBar(const PCPBar & other)
{
  expression_ = other.expression_->clone();

}

PCPBar &PCPBar::operator=(const PCPBar & other)
{
  PCPBar tmp(other);
  swap(tmp);
  return *this;
}

void PCPBar::swap(PCPBar & other)
{
  std::swap(expression_, other.expression_);

}

PCPBar::~PCPBar()
{
  delete(expression_);

}

void PCPBar::accept(Visitor *v)
{
  v->visitPCPBar(this);
}

PCPBar *PCPBar::clone() const
{
  return new PCPBar(*this);
}



/********************   LitStr    ********************/
LitStr::LitStr(String p1)
{
  string_ = p1;

}

LitStr::LitStr(const LitStr & other)
{
  string_ = other.string_;

}

LitStr &LitStr::operator=(const LitStr & other)
{
  LitStr tmp(other);
  swap(tmp);
  return *this;
}

void LitStr::swap(LitStr & other)
{
  std::swap(string_, other.string_);

}

LitStr::~LitStr()
{

}

void LitStr::accept(Visitor *v)
{
  v->visitLitStr(this);
}

LitStr *LitStr::clone() const
{
  return new LitStr(*this);
}



/********************   LitNum    ********************/
LitNum::LitNum(OCLNumber *p1)
{
  oclnumber_ = p1;

}

LitNum::LitNum(const LitNum & other)
{
  oclnumber_ = other.oclnumber_->clone();

}

LitNum &LitNum::operator=(const LitNum & other)
{
  LitNum tmp(other);
  swap(tmp);
  return *this;
}

void LitNum::swap(LitNum & other)
{
  std::swap(oclnumber_, other.oclnumber_);

}

LitNum::~LitNum()
{
  delete(oclnumber_);

}

void LitNum::accept(Visitor *v)
{
  v->visitLitNum(this);
}

LitNum *LitNum::clone() const
{
  return new LitNum(*this);
}



/********************   LitBoolTrue    ********************/
LitBoolTrue::LitBoolTrue()
{

}

LitBoolTrue::LitBoolTrue(const LitBoolTrue & other)
{

}

LitBoolTrue &LitBoolTrue::operator=(const LitBoolTrue & other)
{
  LitBoolTrue tmp(other);
  swap(tmp);
  return *this;
}

void LitBoolTrue::swap(LitBoolTrue & other)
{

}

LitBoolTrue::~LitBoolTrue()
{

}

void LitBoolTrue::accept(Visitor *v)
{
  v->visitLitBoolTrue(this);
}

LitBoolTrue *LitBoolTrue::clone() const
{
  return new LitBoolTrue(*this);
}



/********************   LitBoolFalse    ********************/
LitBoolFalse::LitBoolFalse()
{

}

LitBoolFalse::LitBoolFalse(const LitBoolFalse & other)
{

}

LitBoolFalse &LitBoolFalse::operator=(const LitBoolFalse & other)
{
  LitBoolFalse tmp(other);
  swap(tmp);
  return *this;
}

void LitBoolFalse::swap(LitBoolFalse & other)
{

}

LitBoolFalse::~LitBoolFalse()
{

}

void LitBoolFalse::accept(Visitor *v)
{
  v->visitLitBoolFalse(this);
}

LitBoolFalse *LitBoolFalse::clone() const
{
  return new LitBoolFalse(*this);
}



/********************   STSpec    ********************/
STSpec::STSpec(PathName *p1)
{
  pathname_ = p1;

}

STSpec::STSpec(const STSpec & other)
{
  pathname_ = other.pathname_->clone();

}

STSpec &STSpec::operator=(const STSpec & other)
{
  STSpec tmp(other);
  swap(tmp);
  return *this;
}

void STSpec::swap(STSpec & other)
{
  std::swap(pathname_, other.pathname_);

}

STSpec::~STSpec()
{
  delete(pathname_);

}

void STSpec::accept(Visitor *v)
{
  v->visitSTSpec(this);
}

STSpec *STSpec::clone() const
{
  return new STSpec(*this);
}



/********************   LCollection    ********************/
LCollection::LCollection(CollectionKind *p1, ListCollectionItem *p2)
{
  collectionkind_ = p1;
  listcollectionitem_ = p2;

}

LCollection::LCollection(const LCollection & other)
{
  collectionkind_ = other.collectionkind_->clone();
  listcollectionitem_ = other.listcollectionitem_->clone();

}

LCollection &LCollection::operator=(const LCollection & other)
{
  LCollection tmp(other);
  swap(tmp);
  return *this;
}

void LCollection::swap(LCollection & other)
{
  std::swap(collectionkind_, other.collectionkind_);
  std::swap(listcollectionitem_, other.listcollectionitem_);

}

LCollection::~LCollection()
{
  delete(collectionkind_);
  delete(listcollectionitem_);

}

void LCollection::accept(Visitor *v)
{
  v->visitLCollection(this);
}

LCollection *LCollection::clone() const
{
  return new LCollection(*this);
}



/********************   LCollectionEmpty    ********************/
LCollectionEmpty::LCollectionEmpty(CollectionKind *p1)
{
  collectionkind_ = p1;

}

LCollectionEmpty::LCollectionEmpty(const LCollectionEmpty & other)
{
  collectionkind_ = other.collectionkind_->clone();

}

LCollectionEmpty &LCollectionEmpty::operator=(const LCollectionEmpty & other)
{
  LCollectionEmpty tmp(other);
  swap(tmp);
  return *this;
}

void LCollectionEmpty::swap(LCollectionEmpty & other)
{
  std::swap(collectionkind_, other.collectionkind_);

}

LCollectionEmpty::~LCollectionEmpty()
{
  delete(collectionkind_);

}

void LCollectionEmpty::accept(Visitor *v)
{
  v->visitLCollectionEmpty(this);
}

LCollectionEmpty *LCollectionEmpty::clone() const
{
  return new LCollectionEmpty(*this);
}



/********************   CI    ********************/
CI::CI(Expression *p1)
{
  expression_ = p1;

}

CI::CI(const CI & other)
{
  expression_ = other.expression_->clone();

}

CI &CI::operator=(const CI & other)
{
  CI tmp(other);
  swap(tmp);
  return *this;
}

void CI::swap(CI & other)
{
  std::swap(expression_, other.expression_);

}

CI::~CI()
{
  delete(expression_);

}

void CI::accept(Visitor *v)
{
  v->visitCI(this);
}

CI *CI::clone() const
{
  return new CI(*this);
}



/********************   CIRange    ********************/
CIRange::CIRange(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

CIRange::CIRange(const CIRange & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

CIRange &CIRange::operator=(const CIRange & other)
{
  CIRange tmp(other);
  swap(tmp);
  return *this;
}

void CIRange::swap(CIRange & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

CIRange::~CIRange()
{
  delete(expression_1);
  delete(expression_2);

}

void CIRange::accept(Visitor *v)
{
  v->visitCIRange(this);
}

CIRange *CIRange::clone() const
{
  return new CIRange(*this);
}



/********************   NumInt    ********************/
NumInt::NumInt(Integer p1)
{
  integer_ = p1;

}

NumInt::NumInt(const NumInt & other)
{
  integer_ = other.integer_;

}

NumInt &NumInt::operator=(const NumInt & other)
{
  NumInt tmp(other);
  swap(tmp);
  return *this;
}

void NumInt::swap(NumInt & other)
{
  std::swap(integer_, other.integer_);

}

NumInt::~NumInt()
{

}

void NumInt::accept(Visitor *v)
{
  v->visitNumInt(this);
}

NumInt *NumInt::clone() const
{
  return new NumInt(*this);
}



/********************   NumDouble    ********************/
NumDouble::NumDouble(Double p1)
{
  double_ = p1;

}

NumDouble::NumDouble(const NumDouble & other)
{
  double_ = other.double_;

}

NumDouble &NumDouble::operator=(const NumDouble & other)
{
  NumDouble tmp(other);
  swap(tmp);
  return *this;
}

void NumDouble::swap(NumDouble & other)
{
  std::swap(double_, other.double_);

}

NumDouble::~NumDouble()
{

}

void NumDouble::accept(Visitor *v)
{
  v->visitNumDouble(this);
}

NumDouble *NumDouble::clone() const
{
  return new NumDouble(*this);
}



/********************   LAnd    ********************/
LAnd::LAnd()
{

}

LAnd::LAnd(const LAnd & other)
{

}

LAnd &LAnd::operator=(const LAnd & other)
{
  LAnd tmp(other);
  swap(tmp);
  return *this;
}

void LAnd::swap(LAnd & other)
{

}

LAnd::~LAnd()
{

}

void LAnd::accept(Visitor *v)
{
  v->visitLAnd(this);
}

LAnd *LAnd::clone() const
{
  return new LAnd(*this);
}



/********************   LOr    ********************/
LOr::LOr()
{

}

LOr::LOr(const LOr & other)
{

}

LOr &LOr::operator=(const LOr & other)
{
  LOr tmp(other);
  swap(tmp);
  return *this;
}

void LOr::swap(LOr & other)
{

}

LOr::~LOr()
{

}

void LOr::accept(Visitor *v)
{
  v->visitLOr(this);
}

LOr *LOr::clone() const
{
  return new LOr(*this);
}



/********************   LXor    ********************/
LXor::LXor()
{

}

LXor::LXor(const LXor & other)
{

}

LXor &LXor::operator=(const LXor & other)
{
  LXor tmp(other);
  swap(tmp);
  return *this;
}

void LXor::swap(LXor & other)
{

}

LXor::~LXor()
{

}

void LXor::accept(Visitor *v)
{
  v->visitLXor(this);
}

LXor *LXor::clone() const
{
  return new LXor(*this);
}



/********************   Set    ********************/
Set::Set()
{

}

Set::Set(const Set & other)
{

}

Set &Set::operator=(const Set & other)
{
  Set tmp(other);
  swap(tmp);
  return *this;
}

void Set::swap(Set & other)
{

}

Set::~Set()
{

}

void Set::accept(Visitor *v)
{
  v->visitSet(this);
}

Set *Set::clone() const
{
  return new Set(*this);
}



/********************   Bag    ********************/
Bag::Bag()
{

}

Bag::Bag(const Bag & other)
{

}

Bag &Bag::operator=(const Bag & other)
{
  Bag tmp(other);
  swap(tmp);
  return *this;
}

void Bag::swap(Bag & other)
{

}

Bag::~Bag()
{

}

void Bag::accept(Visitor *v)
{
  v->visitBag(this);
}

Bag *Bag::clone() const
{
  return new Bag(*this);
}



/********************   Sequence    ********************/
Sequence::Sequence()
{

}

Sequence::Sequence(const Sequence & other)
{

}

Sequence &Sequence::operator=(const Sequence & other)
{
  Sequence tmp(other);
  swap(tmp);
  return *this;
}

void Sequence::swap(Sequence & other)
{

}

Sequence::~Sequence()
{

}

void Sequence::accept(Visitor *v)
{
  v->visitSequence(this);
}

Sequence *Sequence::clone() const
{
  return new Sequence(*this);
}



/********************   Collection    ********************/
Collection::Collection()
{

}

Collection::Collection(const Collection & other)
{

}

Collection &Collection::operator=(const Collection & other)
{
  Collection tmp(other);
  swap(tmp);
  return *this;
}

void Collection::swap(Collection & other)
{

}

Collection::~Collection()
{

}

void Collection::accept(Visitor *v)
{
  v->visitCollection(this);
}

Collection *Collection::clone() const
{
  return new Collection(*this);
}



/********************   EEq    ********************/
EEq::EEq()
{

}

EEq::EEq(const EEq & other)
{

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{

}

EEq::~EEq()
{

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq()
{

}

ENEq::ENEq(const ENEq & other)
{

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{

}

ENEq::~ENEq()
{

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   RGT    ********************/
RGT::RGT()
{

}

RGT::RGT(const RGT & other)
{

}

RGT &RGT::operator=(const RGT & other)
{
  RGT tmp(other);
  swap(tmp);
  return *this;
}

void RGT::swap(RGT & other)
{

}

RGT::~RGT()
{

}

void RGT::accept(Visitor *v)
{
  v->visitRGT(this);
}

RGT *RGT::clone() const
{
  return new RGT(*this);
}



/********************   RGTE    ********************/
RGTE::RGTE()
{

}

RGTE::RGTE(const RGTE & other)
{

}

RGTE &RGTE::operator=(const RGTE & other)
{
  RGTE tmp(other);
  swap(tmp);
  return *this;
}

void RGTE::swap(RGTE & other)
{

}

RGTE::~RGTE()
{

}

void RGTE::accept(Visitor *v)
{
  v->visitRGTE(this);
}

RGTE *RGTE::clone() const
{
  return new RGTE(*this);
}



/********************   RLT    ********************/
RLT::RLT()
{

}

RLT::RLT(const RLT & other)
{

}

RLT &RLT::operator=(const RLT & other)
{
  RLT tmp(other);
  swap(tmp);
  return *this;
}

void RLT::swap(RLT & other)
{

}

RLT::~RLT()
{

}

void RLT::accept(Visitor *v)
{
  v->visitRLT(this);
}

RLT *RLT::clone() const
{
  return new RLT(*this);
}



/********************   RLTE    ********************/
RLTE::RLTE()
{

}

RLTE::RLTE(const RLTE & other)
{

}

RLTE &RLTE::operator=(const RLTE & other)
{
  RLTE tmp(other);
  swap(tmp);
  return *this;
}

void RLTE::swap(RLTE & other)
{

}

RLTE::~RLTE()
{

}

void RLTE::accept(Visitor *v)
{
  v->visitRLTE(this);
}

RLTE *RLTE::clone() const
{
  return new RLTE(*this);
}



/********************   AAdd    ********************/
AAdd::AAdd()
{

}

AAdd::AAdd(const AAdd & other)
{

}

AAdd &AAdd::operator=(const AAdd & other)
{
  AAdd tmp(other);
  swap(tmp);
  return *this;
}

void AAdd::swap(AAdd & other)
{

}

AAdd::~AAdd()
{

}

void AAdd::accept(Visitor *v)
{
  v->visitAAdd(this);
}

AAdd *AAdd::clone() const
{
  return new AAdd(*this);
}



/********************   ASub    ********************/
ASub::ASub()
{

}

ASub::ASub(const ASub & other)
{

}

ASub &ASub::operator=(const ASub & other)
{
  ASub tmp(other);
  swap(tmp);
  return *this;
}

void ASub::swap(ASub & other)
{

}

ASub::~ASub()
{

}

void ASub::accept(Visitor *v)
{
  v->visitASub(this);
}

ASub *ASub::clone() const
{
  return new ASub(*this);
}



/********************   MMult    ********************/
MMult::MMult()
{

}

MMult::MMult(const MMult & other)
{

}

MMult &MMult::operator=(const MMult & other)
{
  MMult tmp(other);
  swap(tmp);
  return *this;
}

void MMult::swap(MMult & other)
{

}

MMult::~MMult()
{

}

void MMult::accept(Visitor *v)
{
  v->visitMMult(this);
}

MMult *MMult::clone() const
{
  return new MMult(*this);
}



/********************   MDiv    ********************/
MDiv::MDiv()
{

}

MDiv::MDiv(const MDiv & other)
{

}

MDiv &MDiv::operator=(const MDiv & other)
{
  MDiv tmp(other);
  swap(tmp);
  return *this;
}

void MDiv::swap(MDiv & other)
{

}

MDiv::~MDiv()
{

}

void MDiv::accept(Visitor *v)
{
  v->visitMDiv(this);
}

MDiv *MDiv::clone() const
{
  return new MDiv(*this);
}



/********************   UMin    ********************/
UMin::UMin()
{

}

UMin::UMin(const UMin & other)
{

}

UMin &UMin::operator=(const UMin & other)
{
  UMin tmp(other);
  swap(tmp);
  return *this;
}

void UMin::swap(UMin & other)
{

}

UMin::~UMin()
{

}

void UMin::accept(Visitor *v)
{
  v->visitUMin(this);
}

UMin *UMin::clone() const
{
  return new UMin(*this);
}



/********************   UNot    ********************/
UNot::UNot()
{

}

UNot::UNot(const UNot & other)
{

}

UNot &UNot::operator=(const UNot & other)
{
  UNot tmp(other);
  swap(tmp);
  return *this;
}

void UNot::swap(UNot & other)
{

}

UNot::~UNot()
{

}

void UNot::accept(Visitor *v)
{
  v->visitUNot(this);
}

UNot *UNot::clone() const
{
  return new UNot(*this);
}



/********************   PDot    ********************/
PDot::PDot()
{

}

PDot::PDot(const PDot & other)
{

}

PDot &PDot::operator=(const PDot & other)
{
  PDot tmp(other);
  swap(tmp);
  return *this;
}

void PDot::swap(PDot & other)
{

}

PDot::~PDot()
{

}

void PDot::accept(Visitor *v)
{
  v->visitPDot(this);
}

PDot *PDot::clone() const
{
  return new PDot(*this);
}



/********************   PArrow    ********************/
PArrow::PArrow()
{

}

PArrow::PArrow(const PArrow & other)
{

}

PArrow &PArrow::operator=(const PArrow & other)
{
  PArrow tmp(other);
  swap(tmp);
  return *this;
}

void PArrow::swap(PArrow & other)
{

}

PArrow::~PArrow()
{

}

void PArrow::accept(Visitor *v)
{
  v->visitPArrow(this);
}

PArrow *PArrow::clone() const
{
  return new PArrow(*this);
}




/********************   ListOCLPackage    ********************/

void ListOCLPackage::accept(Visitor *v)
{
  v->visitListOCLPackage(this);
}


ListOCLPackage *ListOCLPackage::clone() const
{
  return new ListOCLPackage(*this);
}


/********************   ListConstrnt    ********************/

void ListConstrnt::accept(Visitor *v)
{
  v->visitListConstrnt(this);
}


ListConstrnt *ListConstrnt::clone() const
{
  return new ListConstrnt(*this);
}


/********************   ListConstrBody    ********************/

void ListConstrBody::accept(Visitor *v)
{
  v->visitListConstrBody(this);
}


ListConstrBody *ListConstrBody::clone() const
{
  return new ListConstrBody(*this);
}


/********************   ListFormalParameter    ********************/

void ListFormalParameter::accept(Visitor *v)
{
  v->visitListFormalParameter(this);
}


ListFormalParameter *ListFormalParameter::clone() const
{
  return new ListFormalParameter(*this);
}


/********************   ListLetExpression    ********************/

void ListLetExpression::accept(Visitor *v)
{
  v->visitListLetExpression(this);
}


ListLetExpression *ListLetExpression::clone() const
{
  return new ListLetExpression(*this);
}


/********************   ListMessageArg    ********************/

void ListMessageArg::accept(Visitor *v)
{
  v->visitListMessageArg(this);
}


ListMessageArg *ListMessageArg::clone() const
{
  return new ListMessageArg(*this);
}


/********************   ListPName    ********************/

void ListPName::accept(Visitor *v)
{
  v->visitListPName(this);
}


ListPName *ListPName::clone() const
{
  return new ListPName(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}


ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}


/********************   ListPCPHelper    ********************/

void ListPCPHelper::accept(Visitor *v)
{
  v->visitListPCPHelper(this);
}


ListPCPHelper *ListPCPHelper::clone() const
{
  return new ListPCPHelper(*this);
}


/********************   ListCollectionItem    ********************/

void ListCollectionItem::accept(Visitor *v)
{
  v->visitListCollectionItem(this);
}


ListCollectionItem *ListCollectionItem::clone() const
{
  return new ListCollectionItem(*this);
}




