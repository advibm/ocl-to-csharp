#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class OCLfile;
class OCLPackage;
class PackageName;
class OCLExpressions;
class Constrnt;
class ConstrBody;
class ContextDeclaration;
class ClassifierContext;
class OperationContext;
class Stereotype;
class OperationName;
class FormalParameter;
class TypeSpecifier;
class CollectionType;
class ReturnType;
class OCLExpression;
class LetExpression;
class IfExpression;
class Expression;
class MessageArg;
class PropertyCall;
class PathName;
class PName;
class PossQualifiers;
class Qualifiers;
class PossTimeExpression;
class PossPropCallParam;
class Declarator;
class DeclaratorVarList;
class PropertyCallParameters;
class PCPHelper;
class OCLLiteral;
class SimpleTypeSpecifier;
class LiteralCollection;
class CollectionItem;
class OCLNumber;
class LogicalOperator;
class CollectionKind;
class EqualityOperator;
class RelationalOperator;
class AddOperator;
class MultiplyOperator;
class UnaryOperator;
class PostfixOperator;
class OCLf;
class Pack;
class PackName;
class Constraints;
class Constr;
class CBDefNamed;
class CBDef;
class CBNamed;
class CB;
class CDOper;
class CDClassif;
class CCType;
class CC;
class OpC;
class OpCRT;
class Pre;
class Post;
class Inv;
class OpName;
class Eq;
class Add;
class Sub;
class LST;
class LSTE;
class GRT;
class GRTE;
class Div;
class Mult;
class NEq;
class Impl;
class Not;
class Or;
class Xor;
class And;
class FP;
class TSsimple;
class TScoll;
class CT;
class RT;
class OCLExp;
class OCLExpLet;
class LENoParam;
class LENoParamType;
class LE;
class LEType;
class IfExp;
class EOpImpl;
class EOpLog;
class EOpEq;
class EOpRel;
class EOpAdd;
class EOpMul;
class EOpUn;
class EExplPropCall;
class EMessage;
class EImplPropCall;
class ELitColl;
class ELit;
class EIfExp;
class ENull;
class MAExpr;
class MAUnspec;
class MAUnspecTyped;
class PCall;
class PathN;
class PN;
class NoQual;
class Qual;
class Quals;
class NoTE;
class AtPre;
class NoPCP;
class PCPs;
class Decl;
class DeclAcc;
class DVL;
class DVLType;
class PCPDecl;
class PCP;
class PCPNoDeclNoParam;
class PCPConcrete;
class PCPComma;
class PCPColon;
class PCPIterate;
class PCPBar;
class LitStr;
class LitNum;
class LitBoolTrue;
class LitBoolFalse;
class STSpec;
class LCollection;
class LCollectionEmpty;
class CI;
class CIRange;
class NumInt;
class NumDouble;
class LAnd;
class LOr;
class LXor;
class Set;
class Bag;
class Sequence;
class Collection;
class EEq;
class ENEq;
class RGT;
class RGTE;
class RLT;
class RLTE;
class AAdd;
class ASub;
class MMult;
class MDiv;
class UMin;
class UNot;
class PDot;
class PArrow;
class ListOCLPackage;
class ListConstrnt;
class ListConstrBody;
class ListFormalParameter;
class ListLetExpression;
class ListMessageArg;
class ListPName;
class ListIdent;
class ListExpression;
class ListPCPHelper;
class ListCollectionItem;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitOCLfile(OCLfile *p) = 0;
  virtual void visitOCLPackage(OCLPackage *p) = 0;
  virtual void visitPackageName(PackageName *p) = 0;
  virtual void visitOCLExpressions(OCLExpressions *p) = 0;
  virtual void visitConstrnt(Constrnt *p) = 0;
  virtual void visitConstrBody(ConstrBody *p) = 0;
  virtual void visitContextDeclaration(ContextDeclaration *p) = 0;
  virtual void visitClassifierContext(ClassifierContext *p) = 0;
  virtual void visitOperationContext(OperationContext *p) = 0;
  virtual void visitStereotype(Stereotype *p) = 0;
  virtual void visitOperationName(OperationName *p) = 0;
  virtual void visitFormalParameter(FormalParameter *p) = 0;
  virtual void visitTypeSpecifier(TypeSpecifier *p) = 0;
  virtual void visitCollectionType(CollectionType *p) = 0;
  virtual void visitReturnType(ReturnType *p) = 0;
  virtual void visitOCLExpression(OCLExpression *p) = 0;
  virtual void visitLetExpression(LetExpression *p) = 0;
  virtual void visitIfExpression(IfExpression *p) = 0;
  virtual void visitExpression(Expression *p) = 0;
  virtual void visitMessageArg(MessageArg *p) = 0;
  virtual void visitPropertyCall(PropertyCall *p) = 0;
  virtual void visitPathName(PathName *p) = 0;
  virtual void visitPName(PName *p) = 0;
  virtual void visitPossQualifiers(PossQualifiers *p) = 0;
  virtual void visitQualifiers(Qualifiers *p) = 0;
  virtual void visitPossTimeExpression(PossTimeExpression *p) = 0;
  virtual void visitPossPropCallParam(PossPropCallParam *p) = 0;
  virtual void visitDeclarator(Declarator *p) = 0;
  virtual void visitDeclaratorVarList(DeclaratorVarList *p) = 0;
  virtual void visitPropertyCallParameters(PropertyCallParameters *p) = 0;
  virtual void visitPCPHelper(PCPHelper *p) = 0;
  virtual void visitOCLLiteral(OCLLiteral *p) = 0;
  virtual void visitSimpleTypeSpecifier(SimpleTypeSpecifier *p) = 0;
  virtual void visitLiteralCollection(LiteralCollection *p) = 0;
  virtual void visitCollectionItem(CollectionItem *p) = 0;
  virtual void visitOCLNumber(OCLNumber *p) = 0;
  virtual void visitLogicalOperator(LogicalOperator *p) = 0;
  virtual void visitCollectionKind(CollectionKind *p) = 0;
  virtual void visitEqualityOperator(EqualityOperator *p) = 0;
  virtual void visitRelationalOperator(RelationalOperator *p) = 0;
  virtual void visitAddOperator(AddOperator *p) = 0;
  virtual void visitMultiplyOperator(MultiplyOperator *p) = 0;
  virtual void visitUnaryOperator(UnaryOperator *p) = 0;
  virtual void visitPostfixOperator(PostfixOperator *p) = 0;
  virtual void visitOCLf(OCLf *p) = 0;
  virtual void visitPack(Pack *p) = 0;
  virtual void visitPackName(PackName *p) = 0;
  virtual void visitConstraints(Constraints *p) = 0;
  virtual void visitConstr(Constr *p) = 0;
  virtual void visitCBDefNamed(CBDefNamed *p) = 0;
  virtual void visitCBDef(CBDef *p) = 0;
  virtual void visitCBNamed(CBNamed *p) = 0;
  virtual void visitCB(CB *p) = 0;
  virtual void visitCDOper(CDOper *p) = 0;
  virtual void visitCDClassif(CDClassif *p) = 0;
  virtual void visitCCType(CCType *p) = 0;
  virtual void visitCC(CC *p) = 0;
  virtual void visitOpC(OpC *p) = 0;
  virtual void visitOpCRT(OpCRT *p) = 0;
  virtual void visitPre(Pre *p) = 0;
  virtual void visitPost(Post *p) = 0;
  virtual void visitInv(Inv *p) = 0;
  virtual void visitOpName(OpName *p) = 0;
  virtual void visitEq(Eq *p) = 0;
  virtual void visitAdd(Add *p) = 0;
  virtual void visitSub(Sub *p) = 0;
  virtual void visitLST(LST *p) = 0;
  virtual void visitLSTE(LSTE *p) = 0;
  virtual void visitGRT(GRT *p) = 0;
  virtual void visitGRTE(GRTE *p) = 0;
  virtual void visitDiv(Div *p) = 0;
  virtual void visitMult(Mult *p) = 0;
  virtual void visitNEq(NEq *p) = 0;
  virtual void visitImpl(Impl *p) = 0;
  virtual void visitNot(Not *p) = 0;
  virtual void visitOr(Or *p) = 0;
  virtual void visitXor(Xor *p) = 0;
  virtual void visitAnd(And *p) = 0;
  virtual void visitFP(FP *p) = 0;
  virtual void visitTSsimple(TSsimple *p) = 0;
  virtual void visitTScoll(TScoll *p) = 0;
  virtual void visitCT(CT *p) = 0;
  virtual void visitRT(RT *p) = 0;
  virtual void visitOCLExp(OCLExp *p) = 0;
  virtual void visitOCLExpLet(OCLExpLet *p) = 0;
  virtual void visitLENoParam(LENoParam *p) = 0;
  virtual void visitLENoParamType(LENoParamType *p) = 0;
  virtual void visitLE(LE *p) = 0;
  virtual void visitLEType(LEType *p) = 0;
  virtual void visitIfExp(IfExp *p) = 0;
  virtual void visitEOpImpl(EOpImpl *p) = 0;
  virtual void visitEOpLog(EOpLog *p) = 0;
  virtual void visitEOpEq(EOpEq *p) = 0;
  virtual void visitEOpRel(EOpRel *p) = 0;
  virtual void visitEOpAdd(EOpAdd *p) = 0;
  virtual void visitEOpMul(EOpMul *p) = 0;
  virtual void visitEOpUn(EOpUn *p) = 0;
  virtual void visitEExplPropCall(EExplPropCall *p) = 0;
  virtual void visitEMessage(EMessage *p) = 0;
  virtual void visitEImplPropCall(EImplPropCall *p) = 0;
  virtual void visitELitColl(ELitColl *p) = 0;
  virtual void visitELit(ELit *p) = 0;
  virtual void visitEIfExp(EIfExp *p) = 0;
  virtual void visitENull(ENull *p) = 0;
  virtual void visitMAExpr(MAExpr *p) = 0;
  virtual void visitMAUnspec(MAUnspec *p) = 0;
  virtual void visitMAUnspecTyped(MAUnspecTyped *p) = 0;
  virtual void visitPCall(PCall *p) = 0;
  virtual void visitPathN(PathN *p) = 0;
  virtual void visitPN(PN *p) = 0;
  virtual void visitNoQual(NoQual *p) = 0;
  virtual void visitQual(Qual *p) = 0;
  virtual void visitQuals(Quals *p) = 0;
  virtual void visitNoTE(NoTE *p) = 0;
  virtual void visitAtPre(AtPre *p) = 0;
  virtual void visitNoPCP(NoPCP *p) = 0;
  virtual void visitPCPs(PCPs *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitDeclAcc(DeclAcc *p) = 0;
  virtual void visitDVL(DVL *p) = 0;
  virtual void visitDVLType(DVLType *p) = 0;
  virtual void visitPCPDecl(PCPDecl *p) = 0;
  virtual void visitPCP(PCP *p) = 0;
  virtual void visitPCPNoDeclNoParam(PCPNoDeclNoParam *p) = 0;
  virtual void visitPCPConcrete(PCPConcrete *p) = 0;
  virtual void visitPCPComma(PCPComma *p) = 0;
  virtual void visitPCPColon(PCPColon *p) = 0;
  virtual void visitPCPIterate(PCPIterate *p) = 0;
  virtual void visitPCPBar(PCPBar *p) = 0;
  virtual void visitLitStr(LitStr *p) = 0;
  virtual void visitLitNum(LitNum *p) = 0;
  virtual void visitLitBoolTrue(LitBoolTrue *p) = 0;
  virtual void visitLitBoolFalse(LitBoolFalse *p) = 0;
  virtual void visitSTSpec(STSpec *p) = 0;
  virtual void visitLCollection(LCollection *p) = 0;
  virtual void visitLCollectionEmpty(LCollectionEmpty *p) = 0;
  virtual void visitCI(CI *p) = 0;
  virtual void visitCIRange(CIRange *p) = 0;
  virtual void visitNumInt(NumInt *p) = 0;
  virtual void visitNumDouble(NumDouble *p) = 0;
  virtual void visitLAnd(LAnd *p) = 0;
  virtual void visitLOr(LOr *p) = 0;
  virtual void visitLXor(LXor *p) = 0;
  virtual void visitSet(Set *p) = 0;
  virtual void visitBag(Bag *p) = 0;
  virtual void visitSequence(Sequence *p) = 0;
  virtual void visitCollection(Collection *p) = 0;
  virtual void visitEEq(EEq *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitRGT(RGT *p) = 0;
  virtual void visitRGTE(RGTE *p) = 0;
  virtual void visitRLT(RLT *p) = 0;
  virtual void visitRLTE(RLTE *p) = 0;
  virtual void visitAAdd(AAdd *p) = 0;
  virtual void visitASub(ASub *p) = 0;
  virtual void visitMMult(MMult *p) = 0;
  virtual void visitMDiv(MDiv *p) = 0;
  virtual void visitUMin(UMin *p) = 0;
  virtual void visitUNot(UNot *p) = 0;
  virtual void visitPDot(PDot *p) = 0;
  virtual void visitPArrow(PArrow *p) = 0;
  virtual void visitListOCLPackage(ListOCLPackage *p) = 0;
  virtual void visitListConstrnt(ListConstrnt *p) = 0;
  virtual void visitListConstrBody(ListConstrBody *p) = 0;
  virtual void visitListFormalParameter(ListFormalParameter *p) = 0;
  virtual void visitListLetExpression(ListLetExpression *p) = 0;
  virtual void visitListMessageArg(ListMessageArg *p) = 0;
  virtual void visitListPName(ListPName *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;
  virtual void visitListPCPHelper(ListPCPHelper *p) = 0;
  virtual void visitListCollectionItem(ListCollectionItem *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class OCLfile : public Visitable
{
public:
  virtual OCLfile *clone() const = 0;

};

class OCLPackage : public Visitable
{
public:
  virtual OCLPackage *clone() const = 0;

};

class PackageName : public Visitable
{
public:
  virtual PackageName *clone() const = 0;

};

class OCLExpressions : public Visitable
{
public:
  virtual OCLExpressions *clone() const = 0;

};

class Constrnt : public Visitable
{
public:
  virtual Constrnt *clone() const = 0;

};

class ConstrBody : public Visitable
{
public:
  virtual ConstrBody *clone() const = 0;

};

class ContextDeclaration : public Visitable
{
public:
  virtual ContextDeclaration *clone() const = 0;

};

class ClassifierContext : public Visitable
{
public:
  virtual ClassifierContext *clone() const = 0;

};

class OperationContext : public Visitable
{
public:
  virtual OperationContext *clone() const = 0;

};

class Stereotype : public Visitable
{
public:
  virtual Stereotype *clone() const = 0;

};

class OperationName : public Visitable
{
public:
  virtual OperationName *clone() const = 0;

};

class FormalParameter : public Visitable
{
public:
  virtual FormalParameter *clone() const = 0;

};

class TypeSpecifier : public Visitable
{
public:
  virtual TypeSpecifier *clone() const = 0;

};

class CollectionType : public Visitable
{
public:
  virtual CollectionType *clone() const = 0;

};

class ReturnType : public Visitable
{
public:
  virtual ReturnType *clone() const = 0;

};

class OCLExpression : public Visitable
{
public:
  virtual OCLExpression *clone() const = 0;

};

class LetExpression : public Visitable
{
public:
  virtual LetExpression *clone() const = 0;

};

class IfExpression : public Visitable
{
public:
  virtual IfExpression *clone() const = 0;

};

class Expression : public Visitable
{
public:
  virtual Expression *clone() const = 0;

};

class MessageArg : public Visitable
{
public:
  virtual MessageArg *clone() const = 0;

};

class PropertyCall : public Visitable
{
public:
  virtual PropertyCall *clone() const = 0;

};

class PathName : public Visitable
{
public:
  virtual PathName *clone() const = 0;

};

class PName : public Visitable
{
public:
  virtual PName *clone() const = 0;

};

class PossQualifiers : public Visitable
{
public:
  virtual PossQualifiers *clone() const = 0;

};

class Qualifiers : public Visitable
{
public:
  virtual Qualifiers *clone() const = 0;

};

class PossTimeExpression : public Visitable
{
public:
  virtual PossTimeExpression *clone() const = 0;

};

class PossPropCallParam : public Visitable
{
public:
  virtual PossPropCallParam *clone() const = 0;

};

class Declarator : public Visitable
{
public:
  virtual Declarator *clone() const = 0;

};

class DeclaratorVarList : public Visitable
{
public:
  virtual DeclaratorVarList *clone() const = 0;

};

class PropertyCallParameters : public Visitable
{
public:
  virtual PropertyCallParameters *clone() const = 0;

};

class PCPHelper : public Visitable
{
public:
  virtual PCPHelper *clone() const = 0;

};

class OCLLiteral : public Visitable
{
public:
  virtual OCLLiteral *clone() const = 0;

};

class SimpleTypeSpecifier : public Visitable
{
public:
  virtual SimpleTypeSpecifier *clone() const = 0;

};

class LiteralCollection : public Visitable
{
public:
  virtual LiteralCollection *clone() const = 0;

};

class CollectionItem : public Visitable
{
public:
  virtual CollectionItem *clone() const = 0;

};

class OCLNumber : public Visitable
{
public:
  virtual OCLNumber *clone() const = 0;

};

class LogicalOperator : public Visitable
{
public:
  virtual LogicalOperator *clone() const = 0;

};

class CollectionKind : public Visitable
{
public:
  virtual CollectionKind *clone() const = 0;

};

class EqualityOperator : public Visitable
{
public:
  virtual EqualityOperator *clone() const = 0;

};

class RelationalOperator : public Visitable
{
public:
  virtual RelationalOperator *clone() const = 0;

};

class AddOperator : public Visitable
{
public:
  virtual AddOperator *clone() const = 0;

};

class MultiplyOperator : public Visitable
{
public:
  virtual MultiplyOperator *clone() const = 0;

};

class UnaryOperator : public Visitable
{
public:
  virtual UnaryOperator *clone() const = 0;

};

class PostfixOperator : public Visitable
{
public:
  virtual PostfixOperator *clone() const = 0;

};



class OCLf : public OCLfile
{
public:
  ListOCLPackage *listoclpackage_;

  OCLf(const OCLf &);
  OCLf &operator=(const OCLf &);
  OCLf(ListOCLPackage *p1);
  ~OCLf();
  virtual void accept(Visitor *v);
  virtual OCLf *clone() const;
  void swap(OCLf &);
};

class Pack : public OCLPackage
{
public:
  PackageName *packagename_;
  OCLExpressions *oclexpressions_;

  Pack(const Pack &);
  Pack &operator=(const Pack &);
  Pack(PackageName *p1, OCLExpressions *p2);
  ~Pack();
  virtual void accept(Visitor *v);
  virtual Pack *clone() const;
  void swap(Pack &);
};

class PackName : public PackageName
{
public:
  PathName *pathname_;

  PackName(const PackName &);
  PackName &operator=(const PackName &);
  PackName(PathName *p1);
  ~PackName();
  virtual void accept(Visitor *v);
  virtual PackName *clone() const;
  void swap(PackName &);
};

class Constraints : public OCLExpressions
{
public:
  ListConstrnt *listconstrnt_;

  Constraints(const Constraints &);
  Constraints &operator=(const Constraints &);
  Constraints(ListConstrnt *p1);
  ~Constraints();
  virtual void accept(Visitor *v);
  virtual Constraints *clone() const;
  void swap(Constraints &);
};

class Constr : public Constrnt
{
public:
  ContextDeclaration *contextdeclaration_;
  ListConstrBody *listconstrbody_;

  Constr(const Constr &);
  Constr &operator=(const Constr &);
  Constr(ContextDeclaration *p1, ListConstrBody *p2);
  ~Constr();
  virtual void accept(Visitor *v);
  virtual Constr *clone() const;
  void swap(Constr &);
};

class CBDefNamed : public ConstrBody
{
public:
  Ident ident_;
  ListLetExpression *listletexpression_;

  CBDefNamed(const CBDefNamed &);
  CBDefNamed &operator=(const CBDefNamed &);
  CBDefNamed(Ident p1, ListLetExpression *p2);
  ~CBDefNamed();
  virtual void accept(Visitor *v);
  virtual CBDefNamed *clone() const;
  void swap(CBDefNamed &);
};

class CBDef : public ConstrBody
{
public:
  ListLetExpression *listletexpression_;

  CBDef(const CBDef &);
  CBDef &operator=(const CBDef &);
  CBDef(ListLetExpression *p1);
  ~CBDef();
  virtual void accept(Visitor *v);
  virtual CBDef *clone() const;
  void swap(CBDef &);
};

class CBNamed : public ConstrBody
{
public:
  Stereotype *stereotype_;
  Ident ident_;
  OCLExpression *oclexpression_;

  CBNamed(const CBNamed &);
  CBNamed &operator=(const CBNamed &);
  CBNamed(Stereotype *p1, Ident p2, OCLExpression *p3);
  ~CBNamed();
  virtual void accept(Visitor *v);
  virtual CBNamed *clone() const;
  void swap(CBNamed &);
};

class CB : public ConstrBody
{
public:
  Stereotype *stereotype_;
  OCLExpression *oclexpression_;

  CB(const CB &);
  CB &operator=(const CB &);
  CB(Stereotype *p1, OCLExpression *p2);
  ~CB();
  virtual void accept(Visitor *v);
  virtual CB *clone() const;
  void swap(CB &);
};

class CDOper : public ContextDeclaration
{
public:
  OperationContext *operationcontext_;

  CDOper(const CDOper &);
  CDOper &operator=(const CDOper &);
  CDOper(OperationContext *p1);
  ~CDOper();
  virtual void accept(Visitor *v);
  virtual CDOper *clone() const;
  void swap(CDOper &);
};

class CDClassif : public ContextDeclaration
{
public:
  ClassifierContext *classifiercontext_;

  CDClassif(const CDClassif &);
  CDClassif &operator=(const CDClassif &);
  CDClassif(ClassifierContext *p1);
  ~CDClassif();
  virtual void accept(Visitor *v);
  virtual CDClassif *clone() const;
  void swap(CDClassif &);
};

class CCType : public ClassifierContext
{
public:
  Ident ident_1;
  Ident ident_2;

  CCType(const CCType &);
  CCType &operator=(const CCType &);
  CCType(Ident p1, Ident p2);
  ~CCType();
  virtual void accept(Visitor *v);
  virtual CCType *clone() const;
  void swap(CCType &);
};

class CC : public ClassifierContext
{
public:
  Ident ident_;

  CC(const CC &);
  CC &operator=(const CC &);
  CC(Ident p1);
  ~CC();
  virtual void accept(Visitor *v);
  virtual CC *clone() const;
  void swap(CC &);
};

class OpC : public OperationContext
{
public:
  Ident ident_;
  OperationName *operationname_;
  ListFormalParameter *listformalparameter_;

  OpC(const OpC &);
  OpC &operator=(const OpC &);
  OpC(Ident p1, OperationName *p2, ListFormalParameter *p3);
  ~OpC();
  virtual void accept(Visitor *v);
  virtual OpC *clone() const;
  void swap(OpC &);
};

class OpCRT : public OperationContext
{
public:
  Ident ident_;
  OperationName *operationname_;
  ListFormalParameter *listformalparameter_;
  ReturnType *returntype_;

  OpCRT(const OpCRT &);
  OpCRT &operator=(const OpCRT &);
  OpCRT(Ident p1, OperationName *p2, ListFormalParameter *p3, ReturnType *p4);
  ~OpCRT();
  virtual void accept(Visitor *v);
  virtual OpCRT *clone() const;
  void swap(OpCRT &);
};

class Pre : public Stereotype
{
public:

  Pre(const Pre &);
  Pre &operator=(const Pre &);
  Pre();
  ~Pre();
  virtual void accept(Visitor *v);
  virtual Pre *clone() const;
  void swap(Pre &);
};

class Post : public Stereotype
{
public:

  Post(const Post &);
  Post &operator=(const Post &);
  Post();
  ~Post();
  virtual void accept(Visitor *v);
  virtual Post *clone() const;
  void swap(Post &);
};

class Inv : public Stereotype
{
public:

  Inv(const Inv &);
  Inv &operator=(const Inv &);
  Inv();
  ~Inv();
  virtual void accept(Visitor *v);
  virtual Inv *clone() const;
  void swap(Inv &);
};

class OpName : public OperationName
{
public:
  Ident ident_;

  OpName(const OpName &);
  OpName &operator=(const OpName &);
  OpName(Ident p1);
  ~OpName();
  virtual void accept(Visitor *v);
  virtual OpName *clone() const;
  void swap(OpName &);
};

class Eq : public OperationName
{
public:

  Eq(const Eq &);
  Eq &operator=(const Eq &);
  Eq();
  ~Eq();
  virtual void accept(Visitor *v);
  virtual Eq *clone() const;
  void swap(Eq &);
};

class Add : public OperationName
{
public:

  Add(const Add &);
  Add &operator=(const Add &);
  Add();
  ~Add();
  virtual void accept(Visitor *v);
  virtual Add *clone() const;
  void swap(Add &);
};

class Sub : public OperationName
{
public:

  Sub(const Sub &);
  Sub &operator=(const Sub &);
  Sub();
  ~Sub();
  virtual void accept(Visitor *v);
  virtual Sub *clone() const;
  void swap(Sub &);
};

class LST : public OperationName
{
public:

  LST(const LST &);
  LST &operator=(const LST &);
  LST();
  ~LST();
  virtual void accept(Visitor *v);
  virtual LST *clone() const;
  void swap(LST &);
};

class LSTE : public OperationName
{
public:

  LSTE(const LSTE &);
  LSTE &operator=(const LSTE &);
  LSTE();
  ~LSTE();
  virtual void accept(Visitor *v);
  virtual LSTE *clone() const;
  void swap(LSTE &);
};

class GRT : public OperationName
{
public:

  GRT(const GRT &);
  GRT &operator=(const GRT &);
  GRT();
  ~GRT();
  virtual void accept(Visitor *v);
  virtual GRT *clone() const;
  void swap(GRT &);
};

class GRTE : public OperationName
{
public:

  GRTE(const GRTE &);
  GRTE &operator=(const GRTE &);
  GRTE();
  ~GRTE();
  virtual void accept(Visitor *v);
  virtual GRTE *clone() const;
  void swap(GRTE &);
};

class Div : public OperationName
{
public:

  Div(const Div &);
  Div &operator=(const Div &);
  Div();
  ~Div();
  virtual void accept(Visitor *v);
  virtual Div *clone() const;
  void swap(Div &);
};

class Mult : public OperationName
{
public:

  Mult(const Mult &);
  Mult &operator=(const Mult &);
  Mult();
  ~Mult();
  virtual void accept(Visitor *v);
  virtual Mult *clone() const;
  void swap(Mult &);
};

class NEq : public OperationName
{
public:

  NEq(const NEq &);
  NEq &operator=(const NEq &);
  NEq();
  ~NEq();
  virtual void accept(Visitor *v);
  virtual NEq *clone() const;
  void swap(NEq &);
};

class Impl : public OperationName
{
public:

  Impl(const Impl &);
  Impl &operator=(const Impl &);
  Impl();
  ~Impl();
  virtual void accept(Visitor *v);
  virtual Impl *clone() const;
  void swap(Impl &);
};

class Not : public OperationName
{
public:

  Not(const Not &);
  Not &operator=(const Not &);
  Not();
  ~Not();
  virtual void accept(Visitor *v);
  virtual Not *clone() const;
  void swap(Not &);
};

class Or : public OperationName
{
public:

  Or(const Or &);
  Or &operator=(const Or &);
  Or();
  ~Or();
  virtual void accept(Visitor *v);
  virtual Or *clone() const;
  void swap(Or &);
};

class Xor : public OperationName
{
public:

  Xor(const Xor &);
  Xor &operator=(const Xor &);
  Xor();
  ~Xor();
  virtual void accept(Visitor *v);
  virtual Xor *clone() const;
  void swap(Xor &);
};

class And : public OperationName
{
public:

  And(const And &);
  And &operator=(const And &);
  And();
  ~And();
  virtual void accept(Visitor *v);
  virtual And *clone() const;
  void swap(And &);
};

class FP : public FormalParameter
{
public:
  Ident ident_;
  TypeSpecifier *typespecifier_;

  FP(const FP &);
  FP &operator=(const FP &);
  FP(Ident p1, TypeSpecifier *p2);
  ~FP();
  virtual void accept(Visitor *v);
  virtual FP *clone() const;
  void swap(FP &);
};

class TSsimple : public TypeSpecifier
{
public:
  SimpleTypeSpecifier *simpletypespecifier_;

  TSsimple(const TSsimple &);
  TSsimple &operator=(const TSsimple &);
  TSsimple(SimpleTypeSpecifier *p1);
  ~TSsimple();
  virtual void accept(Visitor *v);
  virtual TSsimple *clone() const;
  void swap(TSsimple &);
};

class TScoll : public TypeSpecifier
{
public:
  CollectionType *collectiontype_;

  TScoll(const TScoll &);
  TScoll &operator=(const TScoll &);
  TScoll(CollectionType *p1);
  ~TScoll();
  virtual void accept(Visitor *v);
  virtual TScoll *clone() const;
  void swap(TScoll &);
};

class CT : public CollectionType
{
public:
  CollectionKind *collectionkind_;
  SimpleTypeSpecifier *simpletypespecifier_;

  CT(const CT &);
  CT &operator=(const CT &);
  CT(CollectionKind *p1, SimpleTypeSpecifier *p2);
  ~CT();
  virtual void accept(Visitor *v);
  virtual CT *clone() const;
  void swap(CT &);
};

class RT : public ReturnType
{
public:
  TypeSpecifier *typespecifier_;

  RT(const RT &);
  RT &operator=(const RT &);
  RT(TypeSpecifier *p1);
  ~RT();
  virtual void accept(Visitor *v);
  virtual RT *clone() const;
  void swap(RT &);
};

class OCLExp : public OCLExpression
{
public:
  Expression *expression_;

  OCLExp(const OCLExp &);
  OCLExp &operator=(const OCLExp &);
  OCLExp(Expression *p1);
  ~OCLExp();
  virtual void accept(Visitor *v);
  virtual OCLExp *clone() const;
  void swap(OCLExp &);
};

class OCLExpLet : public OCLExpression
{
public:
  ListLetExpression *listletexpression_;
  Expression *expression_;

  OCLExpLet(const OCLExpLet &);
  OCLExpLet &operator=(const OCLExpLet &);
  OCLExpLet(ListLetExpression *p1, Expression *p2);
  ~OCLExpLet();
  virtual void accept(Visitor *v);
  virtual OCLExpLet *clone() const;
  void swap(OCLExpLet &);
};

class LENoParam : public LetExpression
{
public:
  Ident ident_;
  Expression *expression_;

  LENoParam(const LENoParam &);
  LENoParam &operator=(const LENoParam &);
  LENoParam(Ident p1, Expression *p2);
  ~LENoParam();
  virtual void accept(Visitor *v);
  virtual LENoParam *clone() const;
  void swap(LENoParam &);
};

class LENoParamType : public LetExpression
{
public:
  Ident ident_;
  TypeSpecifier *typespecifier_;
  Expression *expression_;

  LENoParamType(const LENoParamType &);
  LENoParamType &operator=(const LENoParamType &);
  LENoParamType(Ident p1, TypeSpecifier *p2, Expression *p3);
  ~LENoParamType();
  virtual void accept(Visitor *v);
  virtual LENoParamType *clone() const;
  void swap(LENoParamType &);
};

class LE : public LetExpression
{
public:
  Ident ident_;
  ListFormalParameter *listformalparameter_;
  Expression *expression_;

  LE(const LE &);
  LE &operator=(const LE &);
  LE(Ident p1, ListFormalParameter *p2, Expression *p3);
  ~LE();
  virtual void accept(Visitor *v);
  virtual LE *clone() const;
  void swap(LE &);
};

class LEType : public LetExpression
{
public:
  Ident ident_;
  ListFormalParameter *listformalparameter_;
  TypeSpecifier *typespecifier_;
  Expression *expression_;

  LEType(const LEType &);
  LEType &operator=(const LEType &);
  LEType(Ident p1, ListFormalParameter *p2, TypeSpecifier *p3, Expression *p4);
  ~LEType();
  virtual void accept(Visitor *v);
  virtual LEType *clone() const;
  void swap(LEType &);
};

class IfExp : public IfExpression
{
public:
  Expression *expression_1;
  Expression *expression_2;
  Expression *expression_3;

  IfExp(const IfExp &);
  IfExp &operator=(const IfExp &);
  IfExp(Expression *p1, Expression *p2, Expression *p3);
  ~IfExp();
  virtual void accept(Visitor *v);
  virtual IfExp *clone() const;
  void swap(IfExp &);
};

class EOpImpl : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  EOpImpl(const EOpImpl &);
  EOpImpl &operator=(const EOpImpl &);
  EOpImpl(Expression *p1, Expression *p2);
  ~EOpImpl();
  virtual void accept(Visitor *v);
  virtual EOpImpl *clone() const;
  void swap(EOpImpl &);
};

class EOpLog : public Expression
{
public:
  Expression *expression_1;
  LogicalOperator *logicaloperator_;
  Expression *expression_2;

  EOpLog(const EOpLog &);
  EOpLog &operator=(const EOpLog &);
  EOpLog(Expression *p1, LogicalOperator *p2, Expression *p3);
  ~EOpLog();
  virtual void accept(Visitor *v);
  virtual EOpLog *clone() const;
  void swap(EOpLog &);
};

class EOpEq : public Expression
{
public:
  Expression *expression_1;
  EqualityOperator *equalityoperator_;
  Expression *expression_2;

  EOpEq(const EOpEq &);
  EOpEq &operator=(const EOpEq &);
  EOpEq(Expression *p1, EqualityOperator *p2, Expression *p3);
  ~EOpEq();
  virtual void accept(Visitor *v);
  virtual EOpEq *clone() const;
  void swap(EOpEq &);
};

class EOpRel : public Expression
{
public:
  Expression *expression_1;
  RelationalOperator *relationaloperator_;
  Expression *expression_2;

  EOpRel(const EOpRel &);
  EOpRel &operator=(const EOpRel &);
  EOpRel(Expression *p1, RelationalOperator *p2, Expression *p3);
  ~EOpRel();
  virtual void accept(Visitor *v);
  virtual EOpRel *clone() const;
  void swap(EOpRel &);
};

class EOpAdd : public Expression
{
public:
  Expression *expression_1;
  AddOperator *addoperator_;
  Expression *expression_2;

  EOpAdd(const EOpAdd &);
  EOpAdd &operator=(const EOpAdd &);
  EOpAdd(Expression *p1, AddOperator *p2, Expression *p3);
  ~EOpAdd();
  virtual void accept(Visitor *v);
  virtual EOpAdd *clone() const;
  void swap(EOpAdd &);
};

class EOpMul : public Expression
{
public:
  Expression *expression_1;
  MultiplyOperator *multiplyoperator_;
  Expression *expression_2;

  EOpMul(const EOpMul &);
  EOpMul &operator=(const EOpMul &);
  EOpMul(Expression *p1, MultiplyOperator *p2, Expression *p3);
  ~EOpMul();
  virtual void accept(Visitor *v);
  virtual EOpMul *clone() const;
  void swap(EOpMul &);
};

class EOpUn : public Expression
{
public:
  UnaryOperator *unaryoperator_;
  Expression *expression_;

  EOpUn(const EOpUn &);
  EOpUn &operator=(const EOpUn &);
  EOpUn(UnaryOperator *p1, Expression *p2);
  ~EOpUn();
  virtual void accept(Visitor *v);
  virtual EOpUn *clone() const;
  void swap(EOpUn &);
};

class EExplPropCall : public Expression
{
public:
  Expression *expression_;
  PostfixOperator *postfixoperator_;
  PropertyCall *propertycall_;

  EExplPropCall(const EExplPropCall &);
  EExplPropCall &operator=(const EExplPropCall &);
  EExplPropCall(Expression *p1, PostfixOperator *p2, PropertyCall *p3);
  ~EExplPropCall();
  virtual void accept(Visitor *v);
  virtual EExplPropCall *clone() const;
  void swap(EExplPropCall &);
};

class EMessage : public Expression
{
public:
  Expression *expression_;
  PathName *pathname_;
  ListMessageArg *listmessagearg_;

  EMessage(const EMessage &);
  EMessage &operator=(const EMessage &);
  EMessage(Expression *p1, PathName *p2, ListMessageArg *p3);
  ~EMessage();
  virtual void accept(Visitor *v);
  virtual EMessage *clone() const;
  void swap(EMessage &);
};

class EImplPropCall : public Expression
{
public:
  PropertyCall *propertycall_;

  EImplPropCall(const EImplPropCall &);
  EImplPropCall &operator=(const EImplPropCall &);
  EImplPropCall(PropertyCall *p1);
  ~EImplPropCall();
  virtual void accept(Visitor *v);
  virtual EImplPropCall *clone() const;
  void swap(EImplPropCall &);
};

class ELitColl : public Expression
{
public:
  LiteralCollection *literalcollection_;

  ELitColl(const ELitColl &);
  ELitColl &operator=(const ELitColl &);
  ELitColl(LiteralCollection *p1);
  ~ELitColl();
  virtual void accept(Visitor *v);
  virtual ELitColl *clone() const;
  void swap(ELitColl &);
};

class ELit : public Expression
{
public:
  OCLLiteral *oclliteral_;

  ELit(const ELit &);
  ELit &operator=(const ELit &);
  ELit(OCLLiteral *p1);
  ~ELit();
  virtual void accept(Visitor *v);
  virtual ELit *clone() const;
  void swap(ELit &);
};

class EIfExp : public Expression
{
public:
  IfExpression *ifexpression_;

  EIfExp(const EIfExp &);
  EIfExp &operator=(const EIfExp &);
  EIfExp(IfExpression *p1);
  ~EIfExp();
  virtual void accept(Visitor *v);
  virtual EIfExp *clone() const;
  void swap(EIfExp &);
};

class ENull : public Expression
{
public:

  ENull(const ENull &);
  ENull &operator=(const ENull &);
  ENull();
  ~ENull();
  virtual void accept(Visitor *v);
  virtual ENull *clone() const;
  void swap(ENull &);
};

class MAExpr : public MessageArg
{
public:
  Expression *expression_;

  MAExpr(const MAExpr &);
  MAExpr &operator=(const MAExpr &);
  MAExpr(Expression *p1);
  ~MAExpr();
  virtual void accept(Visitor *v);
  virtual MAExpr *clone() const;
  void swap(MAExpr &);
};

class MAUnspec : public MessageArg
{
public:

  MAUnspec(const MAUnspec &);
  MAUnspec &operator=(const MAUnspec &);
  MAUnspec();
  ~MAUnspec();
  virtual void accept(Visitor *v);
  virtual MAUnspec *clone() const;
  void swap(MAUnspec &);
};

class MAUnspecTyped : public MessageArg
{
public:
  TypeSpecifier *typespecifier_;

  MAUnspecTyped(const MAUnspecTyped &);
  MAUnspecTyped &operator=(const MAUnspecTyped &);
  MAUnspecTyped(TypeSpecifier *p1);
  ~MAUnspecTyped();
  virtual void accept(Visitor *v);
  virtual MAUnspecTyped *clone() const;
  void swap(MAUnspecTyped &);
};

class PCall : public PropertyCall
{
public:
  PathName *pathname_;
  PossTimeExpression *posstimeexpression_;
  PossQualifiers *possqualifiers_;
  PossPropCallParam *posspropcallparam_;

  PCall(const PCall &);
  PCall &operator=(const PCall &);
  PCall(PathName *p1, PossTimeExpression *p2, PossQualifiers *p3, PossPropCallParam *p4);
  ~PCall();
  virtual void accept(Visitor *v);
  virtual PCall *clone() const;
  void swap(PCall &);
};

class PathN : public PathName
{
public:
  ListPName *listpname_;

  PathN(const PathN &);
  PathN &operator=(const PathN &);
  PathN(ListPName *p1);
  ~PathN();
  virtual void accept(Visitor *v);
  virtual PathN *clone() const;
  void swap(PathN &);
};

class PN : public PName
{
public:
  Ident ident_;

  PN(const PN &);
  PN &operator=(const PN &);
  PN(Ident p1);
  ~PN();
  virtual void accept(Visitor *v);
  virtual PN *clone() const;
  void swap(PN &);
};

class NoQual : public PossQualifiers
{
public:

  NoQual(const NoQual &);
  NoQual &operator=(const NoQual &);
  NoQual();
  ~NoQual();
  virtual void accept(Visitor *v);
  virtual NoQual *clone() const;
  void swap(NoQual &);
};

class Qual : public PossQualifiers
{
public:
  Qualifiers *qualifiers_;

  Qual(const Qual &);
  Qual &operator=(const Qual &);
  Qual(Qualifiers *p1);
  ~Qual();
  virtual void accept(Visitor *v);
  virtual Qual *clone() const;
  void swap(Qual &);
};

class Quals : public Qualifiers
{
public:
  ListExpression *listexpression_;

  Quals(const Quals &);
  Quals &operator=(const Quals &);
  Quals(ListExpression *p1);
  ~Quals();
  virtual void accept(Visitor *v);
  virtual Quals *clone() const;
  void swap(Quals &);
};

class NoTE : public PossTimeExpression
{
public:

  NoTE(const NoTE &);
  NoTE &operator=(const NoTE &);
  NoTE();
  ~NoTE();
  virtual void accept(Visitor *v);
  virtual NoTE *clone() const;
  void swap(NoTE &);
};

class AtPre : public PossTimeExpression
{
public:

  AtPre(const AtPre &);
  AtPre &operator=(const AtPre &);
  AtPre();
  ~AtPre();
  virtual void accept(Visitor *v);
  virtual AtPre *clone() const;
  void swap(AtPre &);
};

class NoPCP : public PossPropCallParam
{
public:

  NoPCP(const NoPCP &);
  NoPCP &operator=(const NoPCP &);
  NoPCP();
  ~NoPCP();
  virtual void accept(Visitor *v);
  virtual NoPCP *clone() const;
  void swap(NoPCP &);
};

class PCPs : public PossPropCallParam
{
public:
  PropertyCallParameters *propertycallparameters_;

  PCPs(const PCPs &);
  PCPs &operator=(const PCPs &);
  PCPs(PropertyCallParameters *p1);
  ~PCPs();
  virtual void accept(Visitor *v);
  virtual PCPs *clone() const;
  void swap(PCPs &);
};

class Decl : public Declarator
{
public:
  DeclaratorVarList *declaratorvarlist_;

  Decl(const Decl &);
  Decl &operator=(const Decl &);
  Decl(DeclaratorVarList *p1);
  ~Decl();
  virtual void accept(Visitor *v);
  virtual Decl *clone() const;
  void swap(Decl &);
};

class DeclAcc : public Declarator
{
public:
  DeclaratorVarList *declaratorvarlist_;
  Ident ident_;
  TypeSpecifier *typespecifier_;
  Expression *expression_;

  DeclAcc(const DeclAcc &);
  DeclAcc &operator=(const DeclAcc &);
  DeclAcc(DeclaratorVarList *p1, Ident p2, TypeSpecifier *p3, Expression *p4);
  ~DeclAcc();
  virtual void accept(Visitor *v);
  virtual DeclAcc *clone() const;
  void swap(DeclAcc &);
};

class DVL : public DeclaratorVarList
{
public:
  ListIdent *listident_;

  DVL(const DVL &);
  DVL &operator=(const DVL &);
  DVL(ListIdent *p1);
  ~DVL();
  virtual void accept(Visitor *v);
  virtual DVL *clone() const;
  void swap(DVL &);
};

class DVLType : public DeclaratorVarList
{
public:
  ListIdent *listident_;
  SimpleTypeSpecifier *simpletypespecifier_;

  DVLType(const DVLType &);
  DVLType &operator=(const DVLType &);
  DVLType(ListIdent *p1, SimpleTypeSpecifier *p2);
  ~DVLType();
  virtual void accept(Visitor *v);
  virtual DVLType *clone() const;
  void swap(DVLType &);
};

class PCPDecl : public PropertyCallParameters
{
public:
  Declarator *declarator_;
  ListExpression *listexpression_;

  PCPDecl(const PCPDecl &);
  PCPDecl &operator=(const PCPDecl &);
  PCPDecl(Declarator *p1, ListExpression *p2);
  ~PCPDecl();
  virtual void accept(Visitor *v);
  virtual PCPDecl *clone() const;
  void swap(PCPDecl &);
};

class PCP : public PropertyCallParameters
{
public:
  ListExpression *listexpression_;

  PCP(const PCP &);
  PCP &operator=(const PCP &);
  PCP(ListExpression *p1);
  ~PCP();
  virtual void accept(Visitor *v);
  virtual PCP *clone() const;
  void swap(PCP &);
};

class PCPNoDeclNoParam : public PropertyCallParameters
{
public:

  PCPNoDeclNoParam(const PCPNoDeclNoParam &);
  PCPNoDeclNoParam &operator=(const PCPNoDeclNoParam &);
  PCPNoDeclNoParam();
  ~PCPNoDeclNoParam();
  virtual void accept(Visitor *v);
  virtual PCPNoDeclNoParam *clone() const;
  void swap(PCPNoDeclNoParam &);
};

class PCPConcrete : public PropertyCallParameters
{
public:
  Expression *expression_;
  ListPCPHelper *listpcphelper_;

  PCPConcrete(const PCPConcrete &);
  PCPConcrete &operator=(const PCPConcrete &);
  PCPConcrete(Expression *p1, ListPCPHelper *p2);
  ~PCPConcrete();
  virtual void accept(Visitor *v);
  virtual PCPConcrete *clone() const;
  void swap(PCPConcrete &);
};

class PCPComma : public PCPHelper
{
public:
  Expression *expression_;

  PCPComma(const PCPComma &);
  PCPComma &operator=(const PCPComma &);
  PCPComma(Expression *p1);
  ~PCPComma();
  virtual void accept(Visitor *v);
  virtual PCPComma *clone() const;
  void swap(PCPComma &);
};

class PCPColon : public PCPHelper
{
public:
  SimpleTypeSpecifier *simpletypespecifier_;

  PCPColon(const PCPColon &);
  PCPColon &operator=(const PCPColon &);
  PCPColon(SimpleTypeSpecifier *p1);
  ~PCPColon();
  virtual void accept(Visitor *v);
  virtual PCPColon *clone() const;
  void swap(PCPColon &);
};

class PCPIterate : public PCPHelper
{
public:
  Ident ident_;
  TypeSpecifier *typespecifier_;
  Expression *expression_;

  PCPIterate(const PCPIterate &);
  PCPIterate &operator=(const PCPIterate &);
  PCPIterate(Ident p1, TypeSpecifier *p2, Expression *p3);
  ~PCPIterate();
  virtual void accept(Visitor *v);
  virtual PCPIterate *clone() const;
  void swap(PCPIterate &);
};

class PCPBar : public PCPHelper
{
public:
  Expression *expression_;

  PCPBar(const PCPBar &);
  PCPBar &operator=(const PCPBar &);
  PCPBar(Expression *p1);
  ~PCPBar();
  virtual void accept(Visitor *v);
  virtual PCPBar *clone() const;
  void swap(PCPBar &);
};

class LitStr : public OCLLiteral
{
public:
  String string_;

  LitStr(const LitStr &);
  LitStr &operator=(const LitStr &);
  LitStr(String p1);
  ~LitStr();
  virtual void accept(Visitor *v);
  virtual LitStr *clone() const;
  void swap(LitStr &);
};

class LitNum : public OCLLiteral
{
public:
  OCLNumber *oclnumber_;

  LitNum(const LitNum &);
  LitNum &operator=(const LitNum &);
  LitNum(OCLNumber *p1);
  ~LitNum();
  virtual void accept(Visitor *v);
  virtual LitNum *clone() const;
  void swap(LitNum &);
};

class LitBoolTrue : public OCLLiteral
{
public:

  LitBoolTrue(const LitBoolTrue &);
  LitBoolTrue &operator=(const LitBoolTrue &);
  LitBoolTrue();
  ~LitBoolTrue();
  virtual void accept(Visitor *v);
  virtual LitBoolTrue *clone() const;
  void swap(LitBoolTrue &);
};

class LitBoolFalse : public OCLLiteral
{
public:

  LitBoolFalse(const LitBoolFalse &);
  LitBoolFalse &operator=(const LitBoolFalse &);
  LitBoolFalse();
  ~LitBoolFalse();
  virtual void accept(Visitor *v);
  virtual LitBoolFalse *clone() const;
  void swap(LitBoolFalse &);
};

class STSpec : public SimpleTypeSpecifier
{
public:
  PathName *pathname_;

  STSpec(const STSpec &);
  STSpec &operator=(const STSpec &);
  STSpec(PathName *p1);
  ~STSpec();
  virtual void accept(Visitor *v);
  virtual STSpec *clone() const;
  void swap(STSpec &);
};

class LCollection : public LiteralCollection
{
public:
  CollectionKind *collectionkind_;
  ListCollectionItem *listcollectionitem_;

  LCollection(const LCollection &);
  LCollection &operator=(const LCollection &);
  LCollection(CollectionKind *p1, ListCollectionItem *p2);
  ~LCollection();
  virtual void accept(Visitor *v);
  virtual LCollection *clone() const;
  void swap(LCollection &);
};

class LCollectionEmpty : public LiteralCollection
{
public:
  CollectionKind *collectionkind_;

  LCollectionEmpty(const LCollectionEmpty &);
  LCollectionEmpty &operator=(const LCollectionEmpty &);
  LCollectionEmpty(CollectionKind *p1);
  ~LCollectionEmpty();
  virtual void accept(Visitor *v);
  virtual LCollectionEmpty *clone() const;
  void swap(LCollectionEmpty &);
};

class CI : public CollectionItem
{
public:
  Expression *expression_;

  CI(const CI &);
  CI &operator=(const CI &);
  CI(Expression *p1);
  ~CI();
  virtual void accept(Visitor *v);
  virtual CI *clone() const;
  void swap(CI &);
};

class CIRange : public CollectionItem
{
public:
  Expression *expression_1;
  Expression *expression_2;

  CIRange(const CIRange &);
  CIRange &operator=(const CIRange &);
  CIRange(Expression *p1, Expression *p2);
  ~CIRange();
  virtual void accept(Visitor *v);
  virtual CIRange *clone() const;
  void swap(CIRange &);
};

class NumInt : public OCLNumber
{
public:
  Integer integer_;

  NumInt(const NumInt &);
  NumInt &operator=(const NumInt &);
  NumInt(Integer p1);
  ~NumInt();
  virtual void accept(Visitor *v);
  virtual NumInt *clone() const;
  void swap(NumInt &);
};

class NumDouble : public OCLNumber
{
public:
  Double double_;

  NumDouble(const NumDouble &);
  NumDouble &operator=(const NumDouble &);
  NumDouble(Double p1);
  ~NumDouble();
  virtual void accept(Visitor *v);
  virtual NumDouble *clone() const;
  void swap(NumDouble &);
};

class LAnd : public LogicalOperator
{
public:

  LAnd(const LAnd &);
  LAnd &operator=(const LAnd &);
  LAnd();
  ~LAnd();
  virtual void accept(Visitor *v);
  virtual LAnd *clone() const;
  void swap(LAnd &);
};

class LOr : public LogicalOperator
{
public:

  LOr(const LOr &);
  LOr &operator=(const LOr &);
  LOr();
  ~LOr();
  virtual void accept(Visitor *v);
  virtual LOr *clone() const;
  void swap(LOr &);
};

class LXor : public LogicalOperator
{
public:

  LXor(const LXor &);
  LXor &operator=(const LXor &);
  LXor();
  ~LXor();
  virtual void accept(Visitor *v);
  virtual LXor *clone() const;
  void swap(LXor &);
};

class Set : public CollectionKind
{
public:

  Set(const Set &);
  Set &operator=(const Set &);
  Set();
  ~Set();
  virtual void accept(Visitor *v);
  virtual Set *clone() const;
  void swap(Set &);
};

class Bag : public CollectionKind
{
public:

  Bag(const Bag &);
  Bag &operator=(const Bag &);
  Bag();
  ~Bag();
  virtual void accept(Visitor *v);
  virtual Bag *clone() const;
  void swap(Bag &);
};

class Sequence : public CollectionKind
{
public:

  Sequence(const Sequence &);
  Sequence &operator=(const Sequence &);
  Sequence();
  ~Sequence();
  virtual void accept(Visitor *v);
  virtual Sequence *clone() const;
  void swap(Sequence &);
};

class Collection : public CollectionKind
{
public:

  Collection(const Collection &);
  Collection &operator=(const Collection &);
  Collection();
  ~Collection();
  virtual void accept(Visitor *v);
  virtual Collection *clone() const;
  void swap(Collection &);
};

class EEq : public EqualityOperator
{
public:

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq();
  ~EEq();
  virtual void accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class ENEq : public EqualityOperator
{
public:

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq();
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class RGT : public RelationalOperator
{
public:

  RGT(const RGT &);
  RGT &operator=(const RGT &);
  RGT();
  ~RGT();
  virtual void accept(Visitor *v);
  virtual RGT *clone() const;
  void swap(RGT &);
};

class RGTE : public RelationalOperator
{
public:

  RGTE(const RGTE &);
  RGTE &operator=(const RGTE &);
  RGTE();
  ~RGTE();
  virtual void accept(Visitor *v);
  virtual RGTE *clone() const;
  void swap(RGTE &);
};

class RLT : public RelationalOperator
{
public:

  RLT(const RLT &);
  RLT &operator=(const RLT &);
  RLT();
  ~RLT();
  virtual void accept(Visitor *v);
  virtual RLT *clone() const;
  void swap(RLT &);
};

class RLTE : public RelationalOperator
{
public:

  RLTE(const RLTE &);
  RLTE &operator=(const RLTE &);
  RLTE();
  ~RLTE();
  virtual void accept(Visitor *v);
  virtual RLTE *clone() const;
  void swap(RLTE &);
};

class AAdd : public AddOperator
{
public:

  AAdd(const AAdd &);
  AAdd &operator=(const AAdd &);
  AAdd();
  ~AAdd();
  virtual void accept(Visitor *v);
  virtual AAdd *clone() const;
  void swap(AAdd &);
};

class ASub : public AddOperator
{
public:

  ASub(const ASub &);
  ASub &operator=(const ASub &);
  ASub();
  ~ASub();
  virtual void accept(Visitor *v);
  virtual ASub *clone() const;
  void swap(ASub &);
};

class MMult : public MultiplyOperator
{
public:

  MMult(const MMult &);
  MMult &operator=(const MMult &);
  MMult();
  ~MMult();
  virtual void accept(Visitor *v);
  virtual MMult *clone() const;
  void swap(MMult &);
};

class MDiv : public MultiplyOperator
{
public:

  MDiv(const MDiv &);
  MDiv &operator=(const MDiv &);
  MDiv();
  ~MDiv();
  virtual void accept(Visitor *v);
  virtual MDiv *clone() const;
  void swap(MDiv &);
};

class UMin : public UnaryOperator
{
public:

  UMin(const UMin &);
  UMin &operator=(const UMin &);
  UMin();
  ~UMin();
  virtual void accept(Visitor *v);
  virtual UMin *clone() const;
  void swap(UMin &);
};

class UNot : public UnaryOperator
{
public:

  UNot(const UNot &);
  UNot &operator=(const UNot &);
  UNot();
  ~UNot();
  virtual void accept(Visitor *v);
  virtual UNot *clone() const;
  void swap(UNot &);
};

class PDot : public PostfixOperator
{
public:

  PDot(const PDot &);
  PDot &operator=(const PDot &);
  PDot();
  ~PDot();
  virtual void accept(Visitor *v);
  virtual PDot *clone() const;
  void swap(PDot &);
};

class PArrow : public PostfixOperator
{
public:

  PArrow(const PArrow &);
  PArrow &operator=(const PArrow &);
  PArrow();
  ~PArrow();
  virtual void accept(Visitor *v);
  virtual PArrow *clone() const;
  void swap(PArrow &);
};



class ListOCLPackage : public Visitable, public std::vector<OCLPackage*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListOCLPackage *clone() const;
};

class ListConstrnt : public Visitable, public std::vector<Constrnt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListConstrnt *clone() const;
};

class ListConstrBody : public Visitable, public std::vector<ConstrBody*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListConstrBody *clone() const;
};

class ListFormalParameter : public Visitable, public std::vector<FormalParameter*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFormalParameter *clone() const;
};

class ListLetExpression : public Visitable, public std::vector<LetExpression*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLetExpression *clone() const;
};

class ListMessageArg : public Visitable, public std::vector<MessageArg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListMessageArg *clone() const;
};

class ListPName : public Visitable, public std::vector<PName*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPName *clone() const;
};

class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

class ListExpression : public Visitable, public std::vector<Expression*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
};

class ListPCPHelper : public Visitable, public std::vector<PCPHelper*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPCPHelper *clone() const;
};

class ListCollectionItem : public Visitable, public std::vector<CollectionItem*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListCollectionItem *clone() const;
};



#endif
